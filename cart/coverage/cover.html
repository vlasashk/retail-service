
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>inmem: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">route256/cart/internal/cart/adapters/inmem/cart.go (100.0%)</option>
				
				<option value="file1">route256/cart/internal/cart/adapters/inmem/storage.go (100.0%)</option>
				
				<option value="file2">route256/cart/internal/cart/adapters/prodservice/clientbuilder/client.go (92.9%)</option>
				
				<option value="file3">route256/cart/internal/cart/adapters/prodservice/prodinfo.go (63.2%)</option>
				
				<option value="file4">route256/cart/internal/cart/adapters/prodservice/roundtripper/metrics.go (82.4%)</option>
				
				<option value="file5">route256/cart/internal/cart/adapters/prodservice/roundtripper/ratelimiter.go (80.0%)</option>
				
				<option value="file6">route256/cart/internal/cart/adapters/prodservice/roundtripper/retry.go (58.8%)</option>
				
				<option value="file7">route256/cart/internal/cart/adapters/prodservice/roundtripper/tracer.go (88.9%)</option>
				
				<option value="file8">route256/cart/internal/cart/adapters/stocks/converter.go (100.0%)</option>
				
				<option value="file9">route256/cart/internal/cart/adapters/stocks/interceptors/metrics.go (100.0%)</option>
				
				<option value="file10">route256/cart/internal/cart/adapters/stocks/stocks.go (83.3%)</option>
				
				<option value="file11">route256/cart/internal/cart/ports/vanilla/handlers/additem/additem.go (95.3%)</option>
				
				<option value="file12">route256/cart/internal/cart/ports/vanilla/handlers/checkout/checkout.go (84.6%)</option>
				
				<option value="file13">route256/cart/internal/cart/ports/vanilla/handlers/errhandle/errhandle.go (80.0%)</option>
				
				<option value="file14">route256/cart/internal/cart/ports/vanilla/handlers/getcart/dto.go (100.0%)</option>
				
				<option value="file15">route256/cart/internal/cart/ports/vanilla/handlers/getcart/getcart.go (84.0%)</option>
				
				<option value="file16">route256/cart/internal/cart/ports/vanilla/handlers/healthz/healthz.go (80.0%)</option>
				
				<option value="file17">route256/cart/internal/cart/ports/vanilla/handlers/removecart/removecart.go (100.0%)</option>
				
				<option value="file18">route256/cart/internal/cart/ports/vanilla/handlers/removeitem/removeitem.go (100.0%)</option>
				
				<option value="file19">route256/cart/internal/cart/ports/vanilla/middleware/logger.go (100.0%)</option>
				
				<option value="file20">route256/cart/internal/cart/ports/vanilla/middleware/metrics.go (92.9%)</option>
				
				<option value="file21">route256/cart/internal/cart/ports/vanilla/middleware/recover.go (50.0%)</option>
				
				<option value="file22">route256/cart/internal/cart/ports/vanilla/middleware/tracer.go (100.0%)</option>
				
				<option value="file23">route256/cart/internal/cart/ports/vanilla/middleware/writer.go (100.0%)</option>
				
				<option value="file24">route256/cart/internal/cart/ports/vanilla/muxer/mux.go (81.8%)</option>
				
				<option value="file25">route256/cart/internal/cart/ports/vanilla/router.go (100.0%)</option>
				
				<option value="file26">route256/cart/internal/cart/resources/resources.go (73.3%)</option>
				
				<option value="file27">route256/cart/internal/cart/service.go (83.3%)</option>
				
				<option value="file28">route256/cart/internal/cart/tracing/tracing.go (90.0%)</option>
				
				<option value="file29">route256/cart/internal/cart/usecase/usecase.go (100.0%)</option>
				
				<option value="file30">route256/cart/internal/cart/utils/converter/converter.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package inmem

import (
        "sync"

        "route256/cart/internal/cart/models"
)

type cart struct {
        mu    sync.RWMutex
        items map[int64]uint16
}

func newCart() *cart <span class="cov6" title="22">{
        return &amp;cart{
                mu:    sync.RWMutex{},
                items: make(map[int64]uint16),
        }
}</span>

func (c *cart) addItem(skuID int64, count uint16) <span class="cov10" title="192">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, ok := c.items[skuID]; ok </span><span class="cov6" title="31">{
                count += c.items[skuID]
        }</span> else<span class="cov9" title="161"> {
                skuCount.Inc()
        }</span>

        <span class="cov10" title="192">c.items[skuID] = count</span>
}

func (c *cart) deleteItem(skuID int64) bool <span class="cov8" title="71">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if _, ok := c.items[skuID]; !ok </span><span class="cov6" title="31">{
                return false
        }</span>

        <span class="cov7" title="40">delete(c.items, skuID)

        return true</span>
}

func (c *cart) getItems() []models.Item <span class="cov5" title="15">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        res := make([]models.Item, 0, len(c.items))

        for skuID, count := range c.items </span><span class="cov9" title="117">{
                res = append(res, models.Item{SkuID: skuID, Count: count})
        }</span>

        <span class="cov5" title="15">return res</span>
}

func (c *cart) getItemsAmount() int <span class="cov4" title="8">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return len(c.items)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package inmem

import (
        "context"
        "sync"

        "route256/cart/internal/cart/models"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        cartCount = promauto.NewGauge(prometheus.GaugeOpts{
                Name: "inmem_cart_count",
                Help: "Current number of carts in the in-memory storage",
        })
        skuCount = promauto.NewGauge(prometheus.GaugeOpts{
                Name: "inmem_skus_count",
                Help: "Current number of SKUs in the in-memory storage in all carts",
        })
)

type Storage struct {
        mu    sync.RWMutex
        carts map[int64]*cart
}

func NewStorage() *Storage <span class="cov6" title="20">{
        return &amp;Storage{
                mu:    sync.RWMutex{},
                carts: make(map[int64]*cart),
        }
}</span>

func (s *Storage) AddItem(_ context.Context, userID, skuID int64, count uint16) error <span class="cov10" title="192">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, ok := s.carts[userID]; !ok </span><span class="cov6" title="22">{
                s.carts[userID] = newCart()
                cartCount.Inc()
        }</span>

        <span class="cov10" title="192">s.carts[userID].addItem(skuID, count)

        return nil</span>
}

func (s *Storage) DeleteItem(_ context.Context, userID, skuID int64) error <span class="cov8" title="72">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, ok := s.carts[userID]; !ok </span><span class="cov1" title="1">{
                return models.ErrCartIsEmpty
        }</span>

        <span class="cov8" title="71">if s.carts[userID].deleteItem(skuID) </span><span class="cov7" title="40">{
                skuCount.Dec()
        }</span>

        <span class="cov8" title="71">return nil</span>
}

func (s *Storage) DeleteItemsByUserID(_ context.Context, userID int64) error <span class="cov4" title="9">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, ok := s.carts[userID]; !ok </span><span class="cov1" title="1">{
                return models.ErrCartIsEmpty
        }</span>

        <span class="cov4" title="8">skuCount.Sub(float64(s.carts[userID].getItemsAmount()))

        delete(s.carts, userID)
        cartCount.Dec()

        return nil</span>
}

func (s *Storage) GetItemsByUserID(_ context.Context, userID int64) ([]models.Item, error) <span class="cov5" title="18">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        if _, ok := s.carts[userID]; !ok </span><span class="cov2" title="3">{
                return nil, models.ErrCartIsEmpty
        }</span>

        <span class="cov5" title="15">items := s.carts[userID].getItems()
        if len(items) == 0 </span><span class="cov2" title="3">{
                return nil, models.ErrCartIsEmpty
        }</span>

        <span class="cov5" title="12">return items, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package clientbuilder

import (
        "net/http"
        "time"
)

type RoundTripperMiddleware func(http.RoundTripper) http.RoundTripper

type ClientBuilder struct {
        client        *http.Client
        roundTrippers []RoundTripperMiddleware
}

func New(timeOut time.Duration) *ClientBuilder <span class="cov1" title="1">{
        return &amp;ClientBuilder{
                client: &amp;http.Client{
                        Timeout: timeOut,
                },
        }
}</span>

func (cb *ClientBuilder) Use(m ...RoundTripperMiddleware) *ClientBuilder <span class="cov10" title="4">{
        if cb.roundTrippers == nil </span><span class="cov1" title="1">{
                cb.roundTrippers = make([]RoundTripperMiddleware, 0, len(m))
        }</span>
        <span class="cov10" title="4">cb.roundTrippers = append(cb.roundTrippers, m...)

        return cb</span>
}

func (cb *ClientBuilder) Build() *http.Client <span class="cov1" title="1">{
        roundTripper := chain(http.DefaultTransport, cb.roundTrippers...)
        cb.client.Transport = roundTripper
        return cb.client
}</span>

// chain оборачивает middleware в обратном порядке, так что первый в списке оборачивает все последующие
func chain(h http.RoundTripper, m ...RoundTripperMiddleware) http.RoundTripper <span class="cov1" title="1">{
        if len(m) &lt; 1 </span><span class="cov0" title="0">{
                return h
        }</span>
        <span class="cov1" title="1">newHandler := h
        for i := len(m) - 1; i &gt;= 0; i-- </span><span class="cov10" title="4">{
                newHandler = m[i](newHandler)
        }</span>
        <span class="cov1" title="1">return newHandler</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package prodservice

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        "route256/cart/config"
        "route256/cart/internal/cart/adapters/prodservice/clientbuilder"
        "route256/cart/internal/cart/adapters/prodservice/roundtripper"
        "route256/cart/internal/cart/models"

        "github.com/go-playground/validator/v10"
        "github.com/rs/zerolog"
)

type Client struct {
        baseURL string
        token   string
        client  *http.Client
}

func New(cfg config.ProductProviderCfg, log zerolog.Logger) *Client <span class="cov1" title="1">{
        log.Debug().Str("host", cfg.Address).Msg("creating new product service client")
        clientBuilder := clientbuilder.New(cfg.Timeout).
                Use(roundtripper.Retry(log, cfg.Retries, cfg.MaxDelayForRetry)).
                Use(roundtripper.Tracing()).
                Use(roundtripper.Limit(log, cfg.RateLimit, cfg.BurstLimit)).
                Use(roundtripper.Metrics())

        return &amp;Client{
                baseURL: cfg.Address,
                token:   cfg.AccessToken,
                client:  clientBuilder.Build(),
        }
}</span>

func (c *Client) GetProduct(ctx context.Context, sku int64) (models.ItemDescription, error) <span class="cov10" title="28">{
        localLog := *zerolog.Ctx(ctx)

        url := fmt.Sprintf("%s/get_product", c.baseURL)

        reqBody := getProductReq{
                Token: c.token,
                SKU:   sku,
        }

        data, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                return models.ItemDescription{}, err
        }</span>

        <span class="cov10" title="28">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                return models.ItemDescription{}, err
        }</span>

        <span class="cov10" title="28">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                return models.ItemDescription{}, err
        }</span>
        <span class="cov10" title="28">defer func() </span><span class="cov10" title="28">{
                if err = resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        localLog.Error().Err(err).Send()
                }</span>
        }()

        <span class="cov10" title="28">if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                        return models.ItemDescription{}, models.ErrNotFound
                }</span>
                <span class="cov0" title="0">return models.ItemDescription{}, fmt.Errorf("failed to fetch item: status %d", resp.StatusCode)</span>
        }

        <span class="cov9" title="27">return c.validateProductResp(localLog, resp.Body)</span>
}

func (c *Client) validateProductResp(localLog zerolog.Logger, resp io.Reader) (models.ItemDescription, error) <span class="cov9" title="27">{
        body, err := io.ReadAll(resp)
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                return models.ItemDescription{}, err
        }</span>

        <span class="cov9" title="27">var respBody getProductResp
        if err = json.Unmarshal(body, &amp;respBody); err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                return models.ItemDescription{}, err
        }</span>

        <span class="cov9" title="27">if err = validator.New(validator.WithRequiredStructEnabled()).Struct(respBody); err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Str("error", models.ErrBadProductInfo.Error()).Send()
                return models.ItemDescription{}, models.ErrBadProductData
        }</span>

        <span class="cov9" title="27">return models.ItemDescription{
                Name:  respBody.Name,
                Price: respBody.Price,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package roundtripper

import (
        "net/http"
        "reflect"
        "strconv"
        "time"
        "unsafe"

        "route256/cart/internal/cart/metrics"
)

const serviceName = "product-service"

type metric struct {
        next http.RoundTripper
}

func Metrics() func(next http.RoundTripper) http.RoundTripper <span class="cov1" title="1">{
        return func(next http.RoundTripper) http.RoundTripper </span><span class="cov1" title="1">{
                return metric{
                        next: next,
                }
        }</span>
}
func (m metric) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov10" title="28">{
        var resp *http.Response
        var err error

        defer func(start time.Time) </span><span class="cov10" title="28">{
                duration := time.Since(start).Seconds()
                if req == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov10" title="28">pattern := req.Method + " " + req.URL.Path

                // Workaround что бы получить паттерн ендпойнта (r.pat.str)
                pat := reflect.ValueOf(req).Elem().FieldByName("pat")
                // Обработка кейса когда у ендпоинта есть паттерн
                if !pat.IsNil() </span><span class="cov0" title="0">{
                        patData := pat.Elem().FieldByName("str")
                        pattern = reflect.NewAt(patData.Type(), unsafe.Pointer(patData.UnsafeAddr())).Elem().String()
                }</span>

                <span class="cov10" title="28">metrics.ExternalRequestDuration.WithLabelValues(serviceName, strconv.Itoa(resp.StatusCode), pattern).Observe(duration)
                metrics.ExternalRequestsTotal.WithLabelValues(serviceName, strconv.Itoa(resp.StatusCode), pattern).Inc()</span>

        }(time.Now())

        <span class="cov10" title="28">resp, err = m.next.RoundTrip(req)

        return resp, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package roundtripper

import (
        "net/http"

        "github.com/rs/zerolog"
        "golang.org/x/time/rate"
)

type limiter struct {
        rateLimiter *rate.Limiter
        log         zerolog.Logger
        next        http.RoundTripper
}

func Limit(log zerolog.Logger, rpsLimit rate.Limit, burstLimit int) func(next http.RoundTripper) http.RoundTripper <span class="cov2" title="2">{
        return func(next http.RoundTripper) http.RoundTripper </span><span class="cov2" title="2">{
                return limiter{
                        rateLimiter: rate.NewLimiter(rpsLimit, burstLimit),
                        log:         log,
                        next:        next,
                }
        }</span>
}

func (l limiter) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov10" title="43">{
        if err := l.rateLimiter.Wait(req.Context()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="43">return l.next.RoundTrip(req)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package roundtripper

import (
        "net/http"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type retryer struct {
        retries               int
        maxDelayBeforeNextTry int
        log                   zerolog.Logger
        next                  http.RoundTripper
}

func Retry(log zerolog.Logger, retries, delay int) func(next http.RoundTripper) http.RoundTripper <span class="cov1" title="1">{
        return func(next http.RoundTripper) http.RoundTripper </span><span class="cov1" title="1">{
                return retryer{
                        retries:               retries,
                        log:                   log,
                        maxDelayBeforeNextTry: delay,
                        next:                  next,
                }
        }</span>
}

func (r retryer) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov10" title="28">{
        var (
                resp *http.Response
                err  error
        )

        sleep := 0
        for i := 0; i &lt; r.retries; i++ </span><span class="cov10" title="28">{
                resp, err = r.next.RoundTrip(req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Send()
                        return nil, err
                }</span>
                <span class="cov10" title="28">if resp.StatusCode != 420 &amp;&amp; resp.StatusCode != 429 </span><span class="cov10" title="28">{
                        break</span>
                }
                <span class="cov0" title="0">log.Warn().Int("retries left", r.retries-1-i).Send()
                if sleep &lt;= r.maxDelayBeforeNextTry </span><span class="cov0" title="0">{
                        sleep++
                }</span>
                <span class="cov0" title="0">if i != r.retries-1 </span><span class="cov0" title="0">{
                        time.Sleep(time.Duration(sleep) * time.Second)
                }</span>
        }

        <span class="cov10" title="28">return resp, err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package roundtripper

import (
        "net/http"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
)

type tracer struct {
        next http.RoundTripper
}

func Tracing() func(next http.RoundTripper) http.RoundTripper <span class="cov1" title="1">{
        return func(next http.RoundTripper) http.RoundTripper </span><span class="cov1" title="1">{
                return tracer{
                        next: next,
                }
        }</span>
}

func (t tracer) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov10" title="28">{
        ctx, span := otel.Tracer("").Start(req.Context(), req.Method+" "+req.URL.Path)
        defer span.End()

        otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))

        resp, err := t.next.RoundTrip(req.WithContext(ctx))
        if err != nil </span><span class="cov0" title="0">{
                span.RecordError(err)
        }</span>

        <span class="cov10" title="28">return resp, err</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package stocks

import (
        "route256/cart/internal/cart/models"
        lomsservicev1 "route256/cart/pkg/api/loms/v1"
)

func orderToDTO(order models.Order) *lomsservicev1.OrderCreateRequest <span class="cov3" title="2">{
        items := make([]*lomsservicev1.Item, 0, len(order.Items))

        for _, item := range order.Items </span><span class="cov4" title="3">{
                items = append(items, &amp;lomsservicev1.Item{
                        Sku:   uint32(item.SkuID),
                        Count: uint32(item.Count),
                })
        }</span>

        <span class="cov3" title="2">return &amp;lomsservicev1.OrderCreateRequest{
                User:  order.UserID,
                Items: items,
        }</span>
}

func skuIDToDTO(skuID int64) *lomsservicev1.StocksInfoRequest <span class="cov10" title="18">{
        return &amp;lomsservicev1.StocksInfoRequest{
                Sku: uint32(skuID),
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package interceptors

import (
        "context"
        "time"

        "route256/cart/internal/cart/metrics"

        "google.golang.org/grpc"
        "google.golang.org/grpc/status"
)

const serviceName = "loms"

func Metrics(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error <span class="cov10" title="20">{
        startTime := time.Now()

        err := invoker(ctx, method, req, reply, cc, opts...)

        duration := time.Since(startTime).Seconds()
        statusCode := status.Code(err).String()

        metrics.ExternalRequestDuration.WithLabelValues(serviceName, statusCode, method).Observe(duration)
        metrics.ExternalRequestsTotal.WithLabelValues(serviceName, statusCode, method).Inc()

        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package stocks

import (
        "context"
        "log"

        "route256/cart/config"
        "route256/cart/internal/cart/adapters/stocks/interceptors"
        "route256/cart/internal/cart/models"
        lomsservicev1 "route256/cart/pkg/api/loms/v1"

        "github.com/pkg/errors"
        "github.com/rs/zerolog"
        "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
        "google.golang.org/grpc"
        "google.golang.org/grpc/backoff"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/status"
)

type Client struct {
        baseURL string
        client  lomsservicev1.LOMSClient
        conn    *grpc.ClientConn
        log     zerolog.Logger
}

func New(cfg config.StocksProviderCfg, log zerolog.Logger) (*Client, error) <span class="cov1" title="1">{
        log.Debug().Str("host", cfg.Address).Msg("creating new stocks service client")
        backoffConfig := backoff.Config{
                BaseDelay:  cfg.BaseDelay,
                Multiplier: cfg.Multiplier,
                Jitter:     cfg.Jitter,
                MaxDelay:   cfg.MaxDelay,
        }

        conn, err := grpc.NewClient(cfg.Address,
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithConnectParams(grpc.ConnectParams{
                        Backoff:           backoffConfig,
                        MinConnectTimeout: cfg.MaxConnTimeout,
                }),
                grpc.WithChainUnaryInterceptor(
                        interceptors.Metrics,
                ),
                grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">client := lomsservicev1.NewLOMSClient(conn)

        return &amp;Client{
                baseURL: cfg.Address,
                log:     log,
                client:  client,
                conn:    conn,
        }, nil</span>
}

func (c *Client) Close() error <span class="cov1" title="1">{
        return c.conn.Close()
}</span>

func (c *Client) OrderCreate(ctx context.Context, order models.Order) (int64, error) <span class="cov3" title="2">{
        resp, err := c.client.OrderCreate(ctx, orderToDTO(order))
        if err != nil </span><span class="cov1" title="1">{
                return 0, handleError(err)
        }</span>

        <span class="cov1" title="1">return resp.OrderID, nil</span>
}

func (c *Client) StocksInfo(ctx context.Context, skuID int64) (uint64, error) <span class="cov10" title="18">{
        resp, err := c.client.StocksInfo(ctx, skuIDToDTO(skuID))
        if err != nil </span><span class="cov1" title="1">{
                return 0, handleError(err)
        }</span>

        <span class="cov9" title="17">return resp.Count, nil</span>
}

func handleError(err error) error <span class="cov3" title="2">{
        st, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                log.Fatalf("Non-gRPC error: %v", err)
        }</span>

        <span class="cov3" title="2">switch st.Code() </span>{
        case codes.NotFound:<span class="cov1" title="1">
                return errors.Wrap(models.ErrNotFound, err.Error())</span>
        case codes.FailedPrecondition:<span class="cov1" title="1">
                return errors.Wrap(models.ErrInsufficientStock, err.Error())</span>
        case codes.Internal:<span class="cov0" title="0">
                return errors.Wrap(models.ErrStockProvider, err.Error())</span>
        default:<span class="cov0" title="0">
                return err</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package additem

import (
        "context"
        "encoding/json"
        "errors"
        "io"
        "net/http"

        "route256/cart/internal/cart/constants"
        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"
        "route256/cart/internal/cart/utils/converter"

        "github.com/go-playground/validator/v10"
        "github.com/rs/zerolog"
)

//go:generate minimock -i CartAdder -p additem_test
type CartAdder interface {
        AddItem(ctx context.Context, userID, skuID int64, count uint16) error
}

type Handler struct {
        adder CartAdder
}

func New(adder CartAdder) *Handler <span class="cov7" title="13">{
        return &amp;Handler{
                adder: adder,
        }
}</span>

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="36">{
        localLog := zerolog.Ctx(r.Context()).With().Str("handler", "add_item").Logger()

        // Логирование внутри парсера
        reqData, err := parseDataFromReq(localLog, r)
        if err != nil </span><span class="cov7" title="11">{
                switch </span>{
                case errors.Is(err, models.ErrInvalidSKUID) || errors.Is(err, models.ErrInvalidUserID) ||
                        errors.Is(err, models.ErrJSONProcessing) || errors.Is(err, models.ErrBadCount):<span class="cov6" title="10">
                        errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusBadRequest)</span>
                case errors.Is(err, models.ErrReadBody):<span class="cov1" title="1">
                        errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                default:<span class="cov0" title="0">
                        errhandle.NewErr(models.ErrAddItem.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                }
                <span class="cov7" title="11">return</span>
        }

        <span class="cov9" title="25">if err = h.adder.AddItem(r.Context(), reqData.UserID, reqData.SKUid, reqData.Count); err != nil </span><span class="cov6" title="8">{
                localLog.Error().Err(err).Send()
                switch </span>{
                case errors.Is(err, models.ErrNotFound):<span class="cov3" title="3">
                        errhandle.NewErr(models.ErrNotFound.Error()).Send(w, localLog, http.StatusPreconditionFailed)</span>
                case errors.Is(err, models.ErrInsufficientStock):<span class="cov2" title="2">
                        errhandle.NewErr(models.ErrInsufficientStock.Error()).Send(w, localLog, http.StatusPreconditionFailed)</span>
                case errors.Is(err, models.ErrItemProvider):<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrItemProvider.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                case errors.Is(err, models.ErrStockProvider):<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrStockProvider.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                default:<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrAddItem.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                }
                <span class="cov6" title="8">return</span>
        }

        <span class="cov8" title="17">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)</span>
}

func parseDataFromReq(log zerolog.Logger, r *http.Request) (itemCountReq, error) <span class="cov10" title="36">{
        var itemData itemCountReq

        data, err := io.ReadAll(r.Body)
        defer func() </span><span class="cov10" title="36">{
                if err = r.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Send()
                }</span>
        }()
        <span class="cov10" title="36">if err != nil </span><span class="cov1" title="1">{
                log.Error().Err(err).Send()
                return itemCountReq{}, models.ErrReadBody
        }</span>

        <span class="cov9" title="35">err = json.Unmarshal(data, &amp;itemData)
        if err != nil </span><span class="cov2" title="2">{
                log.Error().Err(err).Send()
                return itemCountReq{}, models.ErrJSONProcessing
        }</span>

        <span class="cov9" title="33">userID, errUserID := converter.UserToInt(r.PathValue(constants.UserID))
        skuID, errSKUiD := converter.SKUtoInt(r.PathValue(constants.SKUid))
        if err = errors.Join(errUserID, errSKUiD); err != nil </span><span class="cov5" title="6">{
                log.Error().Err(err).Str(constants.UserID, r.PathValue(constants.UserID)).Send()
                return itemCountReq{}, err
        }</span>

        <span class="cov9" title="27">if err = validator.New(validator.WithRequiredStructEnabled()).Struct(itemData); err != nil </span><span class="cov2" title="2">{
                log.Error().Err(err).Send()
                return itemCountReq{}, models.ErrBadCount
        }</span>

        <span class="cov9" title="25">itemData.UserID = userID
        itemData.SKUid = skuID

        return itemData, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package checkout

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"

        "route256/cart/internal/cart/constants"
        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"
        "route256/cart/internal/cart/utils/converter"

        "github.com/rs/zerolog"
)

//go:generate minimock -i CartCheckout -p checkout_test
type CartCheckout interface {
        CartCheckout(ctx context.Context, userID int64) (int64, error)
}

type Handler struct {
        checkout CartCheckout
}

func New(checkout CartCheckout) *Handler <span class="cov8" title="7">{
        return &amp;Handler{
                checkout: checkout,
        }
}</span>

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="10">{
        localLog := zerolog.Ctx(r.Context()).With().Str("handler", "cart_checkout").Logger()

        userID, err := converter.UserToInt(r.PathValue(constants.UserID))
        if err != nil </span><span class="cov3" title="2">{
                localLog.Error().Err(err).Str(constants.UserID, r.PathValue(constants.UserID)).Send()
                errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusBadRequest)
                return
        }</span>

        <span class="cov9" title="8">orderID, err := h.checkout.CartCheckout(r.Context(), userID)
        if err != nil </span><span class="cov8" title="6">{
                localLog.Error().Err(err).Send()
                switch </span>{
                case errors.Is(err, models.ErrCartIsEmpty):<span class="cov3" title="2">
                        errhandle.NewErr(models.ErrCartIsEmpty.Error()).Send(w, localLog, http.StatusNotFound)</span>
                case errors.Is(err, models.ErrNotFound):<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrNotFound.Error()).Send(w, localLog, http.StatusPreconditionFailed)</span>
                case errors.Is(err, models.ErrInsufficientStock):<span class="cov3" title="2">
                        errhandle.NewErr(models.ErrInsufficientStock.Error()).Send(w, localLog, http.StatusPreconditionFailed)</span>
                default:<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrCartCheckout.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                }
                <span class="cov8" title="6">return</span>
        }

        <span class="cov3" title="2">resp := checkoutResp{
                OrderID: orderID,
        }

        data, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                errhandle.NewErr(models.ErrJSONProcessing.Error()).Send(w, localLog, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="2">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if _, err = w.Write(data); err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package errhandle

import (
        "encoding/json"
        "net/http"

        "route256/cart/internal/cart/models"

        "github.com/rs/zerolog"
)

type ErrResp struct {
        Error string `json:"error"`
}

func NewErr(err string) ErrResp <span class="cov10" title="40">{
        return ErrResp{
                Error: err,
        }
}</span>

func (resp ErrResp) Send(w http.ResponseWriter, log zerolog.Logger, code int) <span class="cov10" title="40">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)

        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg(models.ErrJSONProcessing.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package getcart

import "route256/cart/internal/cart/models"

type userCartResp struct {
        Items      []itemResp `json:"items"`
        TotalPrice uint32     `json:"total_price"`
}

type itemResp struct {
        SkuID int64  `json:"sku_id"`
        Name  string `json:"name"`
        Count uint16 `json:"count"`
        Price uint32 `json:"price"`
}

func itemsToDTO(items models.ItemsInCart) userCartResp <span class="cov7" title="6">{
        resp := userCartResp{
                TotalPrice: items.TotalPrice,
        }
        resp.Items = make([]itemResp, 0, len(items.Items))
        for _, item := range items.Items </span><span class="cov10" title="11">{
                resp.Items = append(resp.Items, itemResp{
                        SkuID: item.SkuID,
                        Name:  item.Info.Name,
                        Count: item.Count,
                        Price: item.Info.Price,
                })
        }</span>
        <span class="cov7" title="6">return resp</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package getcart

import (
        "context"
        "encoding/json"
        "errors"
        "net/http"

        "route256/cart/internal/cart/constants"
        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"
        "route256/cart/internal/cart/utils/converter"

        "github.com/rs/zerolog"
)

//go:generate minimock -i CartRetriever -p getcart_test
type CartRetriever interface {
        GetItemsByUserID(ctx context.Context, userID int64) (models.ItemsInCart, error)
}

type Handler struct {
        retriever CartRetriever
}

func New(retriever CartRetriever) *Handler <span class="cov7" title="6">{
        return &amp;Handler{
                retriever: retriever,
        }
}</span>

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="13">{
        localLog := zerolog.Ctx(r.Context()).With().Str("handler", "get_items").Logger()

        userID, err := converter.UserToInt(r.PathValue(constants.UserID))
        if err != nil </span><span class="cov3" title="2">{
                localLog.Error().Err(err).Str(constants.UserID, r.PathValue(constants.UserID)).Send()
                errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusBadRequest)
                return
        }</span>

        <span class="cov9" title="11">items, err := h.retriever.GetItemsByUserID(r.Context(), userID)
        if err != nil </span><span class="cov6" title="5">{
                localLog.Error().Err(err).Send()
                switch </span>{
                case errors.Is(err, models.ErrCartIsEmpty):<span class="cov4" title="3">
                        errhandle.NewErr(models.ErrCartIsEmpty.Error()).Send(w, localLog, http.StatusNotFound)</span>
                case errors.Is(err, models.ErrNotFound):<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrNotFound.Error()).Send(w, localLog, http.StatusPreconditionFailed)</span>
                default:<span class="cov1" title="1">
                        errhandle.NewErr(models.ErrCartCheckout.Error()).Send(w, localLog, http.StatusInternalServerError)</span>
                }
                <span class="cov6" title="5">return</span>
        }

        <span class="cov7" title="6">itemsResp := itemsToDTO(items)

        data, err := json.Marshal(itemsResp)
        if err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
                errhandle.NewErr(models.ErrJSONProcessing.Error()).Send(w, localLog, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov7" title="6">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if _, err = w.Write(data); err != nil </span><span class="cov0" title="0">{
                localLog.Error().Err(err).Send()
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package healthz

import (
        "encoding/json"
        "net/http"

        "github.com/rs/zerolog/log"
)

func HealthCheck(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]string{"status": "ok"}
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Send()
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package removecart

import (
        "context"
        "errors"
        "net/http"

        "route256/cart/internal/cart/constants"
        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"
        "route256/cart/internal/cart/utils/converter"

        "github.com/rs/zerolog"
)

//go:generate minimock -i CartRemover -p removecart_test
type CartRemover interface {
        DeleteItemsByUserID(ctx context.Context, userID int64) error
}
type Handler struct {
        cartRemover CartRemover
}

func New(remover CartRemover) *Handler <span class="cov7" title="4">{
        return &amp;Handler{
                cartRemover: remover,
        }
}</span>

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="7">{
        localLog := zerolog.Ctx(r.Context()).With().Str("handler", "remove_cart").Logger()

        userID, err := converter.UserToInt(r.PathValue(constants.UserID))
        if err != nil </span><span class="cov1" title="1">{
                localLog.Error().Err(err).Str(constants.UserID, r.PathValue(constants.UserID)).Send()
                errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusBadRequest)
                return
        }</span>

        <span class="cov9" title="6">if err = h.cartRemover.DeleteItemsByUserID(r.Context(), userID); err != nil &amp;&amp; !errors.Is(err, models.ErrCartIsEmpty) </span><span class="cov1" title="1">{
                localLog.Error().Err(err).Send()
                errhandle.NewErr(models.ErrRemoveCart.Error()).Send(w, localLog, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="5">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package removeitem

import (
        "context"
        "errors"
        "net/http"

        "route256/cart/internal/cart/constants"
        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"
        "route256/cart/internal/cart/utils/converter"

        "github.com/rs/zerolog"
)

//go:generate minimock -i ItemRemover -p removeitem_test
type ItemRemover interface {
        DeleteItem(ctx context.Context, userID, skuID int64) error
}

type Handler struct {
        itemRemover ItemRemover
}

func New(remover ItemRemover) *Handler <span class="cov7" title="6">{
        return &amp;Handler{
                itemRemover: remover,
        }
}</span>

func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov10" title="12">{
        localLog := zerolog.Ctx(r.Context()).With().Str("handler", "remove_item").Logger()

        userID, errUserID := converter.UserToInt(r.PathValue(constants.UserID))
        skuID, errSKUiD := converter.SKUtoInt(r.PathValue(constants.SKUid))
        if err := errors.Join(errUserID, errSKUiD); err != nil </span><span class="cov4" title="3">{
                localLog.Error().Err(err).Str(constants.UserID, r.PathValue(constants.UserID)).Str(constants.SKUid, r.PathValue(constants.SKUid)).Send()
                errhandle.NewErr(err.Error()).Send(w, localLog, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="9">if err := h.itemRemover.DeleteItem(r.Context(), userID, skuID); err != nil </span><span class="cov1" title="1">{
                localLog.Error().Err(err).Send()
                errhandle.NewErr(models.ErrRemoveItem.Error()).Send(w, localLog, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="8">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "bytes"
        "errors"
        "io"
        "net/http"
        "time"

        "route256/cart/pkg/utils"

        "github.com/rs/zerolog"
)

func LoggingMiddleware(log zerolog.Logger) func(next http.Handler) http.Handler <span class="cov4" title="4">{
        return func(next http.Handler) http.Handler </span><span class="cov4" title="4">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="51">{
                        var requestBody []byte
                        if r.Body != nil </span><span class="cov9" title="48">{
                                bodyBytes, err := io.ReadAll(r.Body)
                                if err == nil </span><span class="cov9" title="48">{
                                        requestBody = bodyBytes
                                        r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
                                }</span>
                        }
                        <span class="cov10" title="51">traceID, spanID := utils.ExtractTraceInfo(r.Context())
                        logger := log.With().Str("trace_id", traceID).Str("span_id", spanID).Logger()

                        logger.Info().
                                Str("method", r.Method).
                                Str("path", r.URL.Path).
                                Str("query", r.URL.RawQuery).
                                Bytes("body", requestBody).
                                Any("headers", r.Header).
                                Send()

                        ww := &amp;statusWriter{
                                statusCode: http.StatusOK,
                                err:        bytes.NewBuffer(nil),
                                w:          w,
                        }

                        defer func(start time.Time) </span><span class="cov10" title="51">{
                                logResp := logger.With().
                                        Int("status_code", ww.statusCode).
                                        Dur("duration", time.Since(start)).
                                        Any("headers", ww.Header()).
                                        Logger()
                                switch </span>{
                                case ww.statusCode &gt;= 400 &amp;&amp; ww.statusCode &lt; 500:<span class="cov7" title="15">
                                        logResp.Warn().Err(errors.New(ww.err.String())).Send()</span>
                                case ww.statusCode &gt;= 500:<span class="cov1" title="1">
                                        logResp.Error().Err(errors.New(ww.err.String())).Send()</span>
                                default:<span class="cov9" title="35">
                                        logResp.Info().Send()</span>
                                }
                        }(time.Now())

                        <span class="cov10" title="51">next.ServeHTTP(ww, r.WithContext(logger.WithContext(r.Context())))</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "bytes"
        "net/http"
        "reflect"
        "strconv"
        "time"
        "unsafe"

        "route256/cart/internal/cart/metrics"
)

func Metrics(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                ww := &amp;statusWriter{
                        statusCode: http.StatusOK,
                        err:        bytes.NewBuffer(nil),
                        w:          w,
                }

                defer func(start time.Time) </span><span class="cov10" title="48">{
                        duration := time.Since(start).Seconds()
                        if r == nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov10" title="48">pattern := r.Method + " " + r.URL.Path

                        // Workaround что бы получить паттерн ендпойнта (r.pat.str)
                        pat := reflect.ValueOf(r).Elem().FieldByName("pat")
                        // Обработка кейса когда у ендпоинт есть патер
                        if !pat.IsNil() </span><span class="cov10" title="48">{
                                patData := pat.Elem().FieldByName("str")
                                pattern = reflect.NewAt(patData.Type(), unsafe.Pointer(patData.UnsafeAddr())).Elem().String()
                        }</span>

                        <span class="cov10" title="48">metrics.RequestDuration.WithLabelValues(strconv.Itoa(ww.statusCode), pattern).Observe(duration)
                        metrics.RequestsTotal.WithLabelValues(strconv.Itoa(ww.statusCode), pattern).Inc()</span>

                }(time.Now())

                <span class="cov10" title="48">next.ServeHTTP(ww, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "net/http"
        "runtime/debug"

        "route256/cart/internal/cart/models"
        "route256/cart/internal/cart/ports/vanilla/handlers/errhandle"

        "github.com/rs/zerolog"
)

func Recover(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                logger := *zerolog.Ctx(r.Context())

                defer func() </span><span class="cov10" title="48">{
                        if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                //nolint:errorlint // rec is not an error type
                                if rec == http.ErrAbortHandler </span><span class="cov0" title="0">{
                                        panic(rec)</span>
                                }
                                <span class="cov0" title="0">logger.Error().Any("panic", rec).Bytes("stack", debug.Stack()).Send()
                                errhandle.NewErr(models.ErrInternalError.Error()).Send(w, logger, http.StatusInternalServerError)
                                return</span>
                        }
                }()

                <span class="cov10" title="48">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "net/http"

        "go.opentelemetry.io/otel"
)

func TraceMiddleware(next http.Handler) http.Handler <span class="cov1" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="48">{
                ctx, span := otel.Tracer("").Start(r.Context(), r.Method+" "+r.URL.Path)
                defer span.End()

                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "bytes"
        "net/http"
)

type statusWriter struct {
        w          http.ResponseWriter
        err        *bytes.Buffer
        statusCode int
}

func (sw *statusWriter) Header() http.Header <span class="cov10" title="150">{
        return sw.w.Header()
}</span>

func (sw *statusWriter) Write(bytes []byte) (int, error) <span class="cov7" title="45">{
        sw.err.Write(bytes)
        return sw.w.Write(bytes)
}</span>

func (sw *statusWriter) WriteHeader(statusCode int) <span class="cov9" title="99">{
        sw.statusCode = statusCode
        sw.w.WriteHeader(statusCode)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package muxer

import "net/http"

type Middleware func(http.Handler) http.Handler

type MyMux struct {
        *http.ServeMux
        middlewares []Middleware // глобальные
}

func NewMyMux() *MyMux <span class="cov1" title="1">{
        return &amp;MyMux{
                ServeMux:    http.NewServeMux(),
                middlewares: make([]Middleware, 0),
        }
}</span>

// Use создает список глобальных middleware в порядке, когда самый первый оборачивает все хендлеры, а самый последний оборачивает дефолтный
func (mux *MyMux) Use(m ...Middleware) <span class="cov10" title="4">{
        if mux.middlewares == nil </span><span class="cov0" title="0">{
                mux.middlewares = make([]Middleware, 0, len(m))
        }</span>
        <span class="cov10" title="4">mux.middlewares = append(mux.middlewares, m...)</span>
}

func (mux *MyMux) Chain() http.Handler <span class="cov1" title="1">{
        return chain(mux, mux.middlewares...)
}</span>

// chain оборачивает middleware в обратном порядке, так что первый в списке оборачивает все последующие
func chain(h http.Handler, m ...Middleware) http.Handler <span class="cov1" title="1">{
        if len(m) &lt; 1 </span><span class="cov0" title="0">{
                return h
        }</span>
        <span class="cov1" title="1">newHandler := h
        for i := len(m) - 1; i &gt;= 0; i-- </span><span class="cov10" title="4">{
                newHandler = m[i](newHandler)
        }</span>
        <span class="cov1" title="1">return newHandler</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package vanilla

import (
        "net/http"
        "net/http/pprof"

        "route256/cart/config"
        "route256/cart/internal/cart/ports/vanilla/handlers/additem"
        "route256/cart/internal/cart/ports/vanilla/handlers/checkout"
        "route256/cart/internal/cart/ports/vanilla/handlers/getcart"
        "route256/cart/internal/cart/ports/vanilla/handlers/healthz"
        "route256/cart/internal/cart/ports/vanilla/handlers/removecart"
        "route256/cart/internal/cart/ports/vanilla/handlers/removeitem"
        "route256/cart/internal/cart/ports/vanilla/middleware"
        "route256/cart/internal/cart/ports/vanilla/muxer"
        "route256/cart/internal/cart/resources"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

func NewServer(cfg config.Config, res resources.Resources) *http.Server <span class="cov8" title="1">{
        mux := muxer.NewMyMux()

        addRoutes(mux, res)
        registerPprofHandlers(mux)

        return &amp;http.Server{
                Addr:    cfg.Address,
                Handler: mux.Chain(),
        }
}</span>

func addRoutes(mux *muxer.MyMux, resources resources.Resources) <span class="cov8" title="1">{
        mux.Use(middleware.TraceMiddleware)
        mux.Use(middleware.LoggingMiddleware(resources.Log))
        mux.Use(middleware.Metrics)
        mux.Use(middleware.Recover)

        mux.Handle("POST /user/{user_id}/cart/{sku_id}", additem.New(resources.UseCase))
        mux.Handle("DELETE /user/{user_id}/cart/{sku_id}", removeitem.New(resources.UseCase))
        mux.Handle("DELETE /user/{user_id}/cart", removecart.New(resources.UseCase))
        mux.Handle("GET /user/{user_id}/cart/list", getcart.New(resources.UseCase))
        mux.Handle("GET /user/{user_id}/cart/checkout", checkout.New(resources.UseCase))

        mux.Handle("GET /metrics", promhttp.Handler())

        mux.HandleFunc("GET /healthz", healthz.HealthCheck)
}</span>

func registerPprofHandlers(mux *muxer.MyMux) <span class="cov8" title="1">{
        mux.HandleFunc("/debug/pprof/", pprof.Index)
        mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
        mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        mux.HandleFunc("/debug/pprof/trace", pprof.Trace)

        mux.Handle("/debug/pprof/goroutine", pprof.Handler("goroutine"))
        mux.Handle("/debug/pprof/heap", pprof.Handler("heap"))
        mux.Handle("/debug/pprof/threadcreate", pprof.Handler("threadcreate"))
        mux.Handle("/debug/pprof/block", pprof.Handler("block"))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package resources

import (
        "context"

        "route256/cart/config"
        "route256/cart/internal/cart/adapters/inmem"
        "route256/cart/internal/cart/adapters/prodservice"
        "route256/cart/internal/cart/adapters/stocks"
        "route256/cart/internal/cart/tracing"
        "route256/cart/internal/cart/usecase"
        "route256/cart/pkg/logger"

        "github.com/rs/zerolog"
)

type Resources struct {
        Log           zerolog.Logger
        UseCase       *usecase.UseCase
        stopResources []func() error
}

func NewResources(ctx context.Context, cfg config.Config) (Resources, error) <span class="cov1" title="1">{
        log, err := logger.New(cfg.LoggerLVL, cfg.ServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">stocksProvider, err := stocks.New(cfg.StocksProvider, log)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">inMemStorage := inmem.NewStorage()
        productProvider := prodservice.New(cfg.ProductProvider, log)

        trace, err := tracing.New(ctx, cfg.Telemetry)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">return Resources{
                Log: log,
                UseCase: usecase.New(
                        inMemStorage,
                        inMemStorage,
                        inMemStorage,
                        inMemStorage,
                        productProvider,
                        stocksProvider,
                ),
                stopResources: []func() error{
                        stocksProvider.Close,
                        trace.Close,
                },
        }, nil</span>
}

func (r Resources) Stop() <span class="cov1" title="1">{
        for _, stop := range r.stopResources </span><span class="cov10" title="2">{
                if err := stop(); err != nil </span><span class="cov0" title="0">{
                        r.Log.Error().Err(err).Send()
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package cart

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os/signal"
        "syscall"
        "time"

        "route256/cart/config"
        "route256/cart/internal/cart/ports/vanilla"
        "route256/cart/internal/cart/resources"
        "route256/cart/pkg/errorgoup"

        "github.com/rs/zerolog/log"
)

const gracefulTimeout = 10 * time.Second

func Run(ctx context.Context, cfg config.Config) error <span class="cov8" title="1">{
        ctx, cancel := signal.NotifyContext(ctx, syscall.SIGINT, syscall.SIGTERM)
        defer cancel()

        res, err := resources.NewResources(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer res.Stop()

        srv := vanilla.NewServer(cfg, res)

        g, gCtx := errorgoup.WithContext(ctx)
        g.Go(func() error </span><span class="cov8" title="1">{
                log.Info().Msg(fmt.Sprintf("starting server: %s", cfg.Address))
                if err = srv.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                &lt;-gCtx.Done()
                log.Info().Msg("Got interruption signal")
                shutDownCtx, cancel := context.WithTimeout(context.Background(), gracefulTimeout)
                defer cancel()
                return srv.Shutdown(shutDownCtx)
        }</span>)

        <span class="cov8" title="1">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Send()
                return err
        }</span>

        <span class="cov8" title="1">log.Info().Msg("server was gracefully shut down")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package tracing

import (
        "context"
        "time"

        "route256/cart/config"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        sdktrace "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.25.0"
)

type Tracer struct {
        *sdktrace.TracerProvider
}

func New(ctx context.Context, cfg config.TelemetryCfg) (Tracer, error) <span class="cov8" title="1">{
        exporter, err := otlptracegrpc.New(ctx,
                otlptracegrpc.WithEndpoint(cfg.Address),
                otlptracegrpc.WithInsecure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return Tracer{}, err
        }</span>

        <span class="cov8" title="1">tp := sdktrace.NewTracerProvider(
                sdktrace.WithBatcher(exporter),
                sdktrace.WithResource(resource.NewWithAttributes(
                        semconv.SchemaURL,
                        semconv.ServiceNameKey.String(cfg.ServiceName),
                )),
        )

        otel.SetTracerProvider(tp)
        otel.SetTextMapPropagator(propagation.TraceContext{})

        return Tracer{tp}, nil</span>
}

func (t Tracer) Close() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*2)
        defer cancel()
        return t.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package usecase

import (
        "context"
        "errors"
        "sort"
        "sync"
        "time"

        "route256/cart/internal/cart/models"
        "route256/cart/pkg/errorgoup"

        "github.com/rs/zerolog/log"
)

//go:generate minimock -i cartAdder -p usecase_test
type cartAdder interface {
        AddItem(ctx context.Context, userID, skuID int64, count uint16) error
}

//go:generate minimock -i itemRemover -p usecase_test
type itemRemover interface {
        DeleteItem(ctx context.Context, userID, skuID int64) error
}

//go:generate minimock -i cartRemover -p usecase_test
type cartRemover interface {
        DeleteItemsByUserID(ctx context.Context, userID int64) error
}

//go:generate minimock -i cartRetriever -p usecase_test
type cartRetriever interface {
        GetItemsByUserID(ctx context.Context, userID int64) ([]models.Item, error)
}

//go:generate minimock -i productProvider -p usecase_test
type productProvider interface {
        GetProduct(ctx context.Context, sku int64) (models.ItemDescription, error)
}

//go:generate minimock -i stocksProvider -p usecase_test
type stocksProvider interface {
        OrderCreate(ctx context.Context, order models.Order) (int64, error)
        StocksInfo(ctx context.Context, skuID int64) (uint64, error)
}

type UseCase struct {
        adder         cartAdder
        itemRemover   itemRemover
        cartRemover   cartRemover
        retriever     cartRetriever
        prodProvider  productProvider
        stockProvider stocksProvider
}

func New(
        adder cartAdder,
        itemRemover itemRemover,
        cartRemover cartRemover,
        retriever cartRetriever,
        prodProvider productProvider,
        stockProvider stocksProvider,
) *UseCase <span class="cov9" title="21">{
        return &amp;UseCase{
                adder:         adder,
                itemRemover:   itemRemover,
                cartRemover:   cartRemover,
                retriever:     retriever,
                prodProvider:  prodProvider,
                stockProvider: stockProvider,
        }
}</span>

func (uc *UseCase) AddItem(ctx context.Context, userID int64, skuID int64, count uint16) error <span class="cov10" title="26">{
        _, err := uc.prodProvider.GetProduct(ctx, skuID)
        if err != nil </span><span class="cov4" title="3">{
                if !errors.Is(err, models.ErrNotFound) </span><span class="cov1" title="1">{
                        return models.ErrItemProvider
                }</span>
                <span class="cov2" title="2">return err</span>
        }

        <span class="cov9" title="23">available, err := uc.stockProvider.StocksInfo(ctx, skuID)
        if err != nil </span><span class="cov4" title="3">{
                if !errors.Is(err, models.ErrNotFound) </span><span class="cov1" title="1">{
                        return models.ErrStockProvider
                }</span>
                <span class="cov2" title="2">return err</span>
        }

        <span class="cov9" title="20">if available &lt; uint64(count) </span><span class="cov2" title="2">{
                return models.ErrInsufficientStock
        }</span>

        <span class="cov8" title="18">return uc.adder.AddItem(ctx, userID, skuID, count)</span>
}

func (uc *UseCase) DeleteItem(ctx context.Context, userID int64, skuID int64) error <span class="cov7" title="9">{
        return uc.itemRemover.DeleteItem(ctx, userID, skuID)
}</span>

func (uc *UseCase) DeleteItemsByUserID(ctx context.Context, userID int64) error <span class="cov5" title="6">{
        return uc.cartRemover.DeleteItemsByUserID(ctx, userID)
}</span>

func (uc *UseCase) CartCheckout(ctx context.Context, userID int64) (int64, error) <span class="cov5" title="6">{
        itemSKUs, err := uc.retriever.GetItemsByUserID(ctx, userID)
        if err != nil </span><span class="cov2" title="2">{
                return 0, err
        }</span>

        <span class="cov4" title="4">order := models.Order{
                UserID: userID,
                Items:  itemSKUs,
        }

        orderID, err := uc.stockProvider.OrderCreate(ctx, order)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        // Не будем прокидывать ошибку на весь хендлер, если не удалось удалить корзину (Только залогируем).
        // Так как заказ был успешно зарегистрирован и стоки забронированы для пользователя
        <span class="cov4" title="3">err = uc.cartRemover.DeleteItemsByUserID(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                log.Error().Err(err).Caller().Send()
        }</span>

        <span class="cov4" title="3">return orderID, nil</span>
}

func (uc *UseCase) GetItemsByUserID(ctx context.Context, userID int64) (models.ItemsInCart, error) <span class="cov8" title="13">{
        itemSKUs, err := uc.retriever.GetItemsByUserID(ctx, userID)
        if err != nil </span><span class="cov4" title="3">{
                return models.ItemsInCart{}, err
        }</span>

        <span class="cov7" title="10">cart, err := calcCart(ctx, uc.prodProvider, itemSKUs)
        if err != nil </span><span class="cov2" title="2">{
                return models.ItemsInCart{}, err
        }</span>

        <span class="cov6" title="8">return cart, nil</span>
}

func calcCart(ctx context.Context, provider productProvider, itemSKUs []models.Item) (models.ItemsInCart, error) <span class="cov7" title="10">{
        cart := models.ItemsInCart{
                Items:      make([]models.Item, 0, len(itemSKUs)),
                TotalPrice: 0,
        }
        itemChan := make(chan models.Item, len(itemSKUs))

        // горутина для сбора асинхронных ответов от Product Service для формирования корзины
        // (должна завершиться только после получения всех ответов от сервиса)
        wg := sync.WaitGroup{}
        wg.Add(1)
        go func() </span><span class="cov7" title="10">{
                defer wg.Done()
                for item := range itemChan </span><span class="cov8" title="16">{
                        cart.TotalPrice += uint32(item.Count) * item.Info.Price
                        cart.Items = append(cart.Items, item)
                }</span>
        }()

        // errgroup для асинхронного опроса Product Service
        <span class="cov7" title="10">eg, gCtx := errorgoup.WithContext(ctx)
        for _, item := range itemSKUs </span><span class="cov8" title="18">{
                item := item
                eg.Go(func() error </span><span class="cov8" title="18">{
                        ctx, cancel := context.WithTimeout(gCtx, time.Second*2)
                        defer cancel()

                        itemInfo, err := provider.GetProduct(ctx, item.SkuID)
                        if err != nil </span><span class="cov2" title="2">{
                                return err
                        }</span>

                        <span class="cov8" title="16">item.Info = itemInfo
                        itemChan &lt;- item
                        return nil</span>
                })
        }
        <span class="cov7" title="10">if err := eg.Wait(); err != nil </span><span class="cov2" title="2">{
                close(itemChan)
                return models.ItemsInCart{}, err
        }</span>

        <span class="cov6" title="8">close(itemChan)
        wg.Wait()

        sort.Slice(cart.Items, func(i, j int) bool </span><span class="cov6" title="7">{
                return cart.Items[i].SkuID &lt; cart.Items[j].SkuID
        }</span>)

        <span class="cov6" title="8">return cart, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package converter

import (
        "strconv"

        "route256/cart/internal/cart/models"
)

func UserToInt(val string) (int64, error) <span class="cov10" title="75">{
        userID, err := strconv.ParseInt(val, 10, 64)
        if err != nil || userID &lt;= 0 </span><span class="cov5" title="11">{
                return 0, models.ErrInvalidUserID
        }</span>
        <span class="cov9" title="64">return userID, nil</span>
}

func SKUtoInt(val string) (int64, error) <span class="cov8" title="45">{
        userID, err := strconv.ParseInt(val, 10, 64)
        if err != nil || userID &lt;= 0 </span><span class="cov4" title="6">{
                return 0, models.ErrInvalidSKUID
        }</span>
        <span class="cov8" title="39">return userID, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
