// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package usecase_test

//go:generate minimock -i route256/loms/internal/loms/usecase.orderManager -o order_manager_mock_test.go -n OrderManagerMock -p usecase_test

import (
	"context"
	"route256/loms/internal/loms/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderManagerMock implements orderManager
type OrderManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, order models.Order) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, order models.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrderManagerMockCreate

	funcGetByOrderID          func(ctx context.Context, orderID int64) (o1 models.Order, err error)
	inspectFuncGetByOrderID   func(ctx context.Context, orderID int64)
	afterGetByOrderIDCounter  uint64
	beforeGetByOrderIDCounter uint64
	GetByOrderIDMock          mOrderManagerMockGetByOrderID

	funcSetStatus          func(ctx context.Context, orderID int64, status models.OrderStatus) (err error)
	inspectFuncSetStatus   func(ctx context.Context, orderID int64, status models.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderManagerMockSetStatus
}

// NewOrderManagerMock returns a mock for orderManager
func NewOrderManagerMock(t minimock.Tester) *OrderManagerMock {
	m := &OrderManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mOrderManagerMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrderManagerMockCreateParams{}

	m.GetByOrderIDMock = mOrderManagerMockGetByOrderID{mock: m}
	m.GetByOrderIDMock.callArgs = []*OrderManagerMockGetByOrderIDParams{}

	m.SetStatusMock = mOrderManagerMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderManagerMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderManagerMockCreate struct {
	optional           bool
	mock               *OrderManagerMock
	defaultExpectation *OrderManagerMockCreateExpectation
	expectations       []*OrderManagerMockCreateExpectation

	callArgs []*OrderManagerMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderManagerMockCreateExpectation specifies expectation struct of the orderManager.Create
type OrderManagerMockCreateExpectation struct {
	mock      *OrderManagerMock
	params    *OrderManagerMockCreateParams
	paramPtrs *OrderManagerMockCreateParamPtrs
	results   *OrderManagerMockCreateResults
	Counter   uint64
}

// OrderManagerMockCreateParams contains parameters of the orderManager.Create
type OrderManagerMockCreateParams struct {
	ctx   context.Context
	order models.Order
}

// OrderManagerMockCreateParamPtrs contains pointers to parameters of the orderManager.Create
type OrderManagerMockCreateParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// OrderManagerMockCreateResults contains results of the orderManager.Create
type OrderManagerMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrderManagerMockCreate) Optional() *mOrderManagerMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for orderManager.Create
func (mmCreate *mOrderManagerMockCreate) Expect(ctx context.Context, order models.Order) *mOrderManagerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderManagerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrderManagerMockCreateParams{ctx, order}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for orderManager.Create
func (mmCreate *mOrderManagerMockCreate) ExpectCtxParam1(ctx context.Context) *mOrderManagerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderManagerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderManagerMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectOrderParam2 sets up expected param order for orderManager.Create
func (mmCreate *mOrderManagerMockCreate) ExpectOrderParam2(order models.Order) *mOrderManagerMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderManagerMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrderManagerMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.order = &order

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the orderManager.Create
func (mmCreate *mOrderManagerMockCreate) Inspect(f func(ctx context.Context, order models.Order)) *mOrderManagerMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrderManagerMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by orderManager.Create
func (mmCreate *mOrderManagerMockCreate) Return(i1 int64, err error) *OrderManagerMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrderManagerMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrderManagerMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the orderManager.Create method
func (mmCreate *mOrderManagerMockCreate) Set(f func(ctx context.Context, order models.Order) (i1 int64, err error)) *OrderManagerMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the orderManager.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the orderManager.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the orderManager.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrderManagerMockCreate) When(ctx context.Context, order models.Order) *OrderManagerMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrderManagerMock.Create mock is already set by Set")
	}

	expectation := &OrderManagerMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &OrderManagerMockCreateParams{ctx, order},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up orderManager.Create return parameters for the expectation previously defined by the When method
func (e *OrderManagerMockCreateExpectation) Then(i1 int64, err error) *OrderManagerMock {
	e.results = &OrderManagerMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times orderManager.Create should be invoked
func (mmCreate *mOrderManagerMockCreate) Times(n uint64) *mOrderManagerMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrderManagerMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mOrderManagerMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements orderManager
func (mmCreate *OrderManagerMock) Create(ctx context.Context, order models.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, order)
	}

	mm_params := OrderManagerMockCreateParams{ctx, order}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrderManagerMockCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrderManagerMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreate.t.Errorf("OrderManagerMock.Create got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrderManagerMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrderManagerMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, order)
	}
	mmCreate.t.Fatalf("Unexpected call to OrderManagerMock.Create. %v %v", ctx, order)
	return
}

// CreateAfterCounter returns a count of finished OrderManagerMock.Create invocations
func (mmCreate *OrderManagerMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrderManagerMock.Create invocations
func (mmCreate *OrderManagerMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrderManagerMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrderManagerMockCreate) Calls() []*OrderManagerMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrderManagerMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrderManagerMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrderManagerMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderManagerMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderManagerMock.Create")
		} else {
			m.t.Errorf("Expected call to OrderManagerMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to OrderManagerMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderManagerMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mOrderManagerMockGetByOrderID struct {
	optional           bool
	mock               *OrderManagerMock
	defaultExpectation *OrderManagerMockGetByOrderIDExpectation
	expectations       []*OrderManagerMockGetByOrderIDExpectation

	callArgs []*OrderManagerMockGetByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderManagerMockGetByOrderIDExpectation specifies expectation struct of the orderManager.GetByOrderID
type OrderManagerMockGetByOrderIDExpectation struct {
	mock      *OrderManagerMock
	params    *OrderManagerMockGetByOrderIDParams
	paramPtrs *OrderManagerMockGetByOrderIDParamPtrs
	results   *OrderManagerMockGetByOrderIDResults
	Counter   uint64
}

// OrderManagerMockGetByOrderIDParams contains parameters of the orderManager.GetByOrderID
type OrderManagerMockGetByOrderIDParams struct {
	ctx     context.Context
	orderID int64
}

// OrderManagerMockGetByOrderIDParamPtrs contains pointers to parameters of the orderManager.GetByOrderID
type OrderManagerMockGetByOrderIDParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// OrderManagerMockGetByOrderIDResults contains results of the orderManager.GetByOrderID
type OrderManagerMockGetByOrderIDResults struct {
	o1  models.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Optional() *mOrderManagerMockGetByOrderID {
	mmGetByOrderID.optional = true
	return mmGetByOrderID
}

// Expect sets up expected params for orderManager.GetByOrderID
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Expect(ctx context.Context, orderID int64) *mOrderManagerMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderManagerMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by ExpectParams functions")
	}

	mmGetByOrderID.defaultExpectation.params = &OrderManagerMockGetByOrderIDParams{ctx, orderID}
	for _, e := range mmGetByOrderID.expectations {
		if minimock.Equal(e.params, mmGetByOrderID.defaultExpectation.params) {
			mmGetByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderID.defaultExpectation.params)
		}
	}

	return mmGetByOrderID
}

// ExpectCtxParam1 sets up expected param ctx for orderManager.GetByOrderID
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) ExpectCtxParam1(ctx context.Context) *mOrderManagerMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderManagerMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderManagerMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetByOrderID
}

// ExpectOrderIDParam2 sets up expected param orderID for orderManager.GetByOrderID
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) ExpectOrderIDParam2(orderID int64) *mOrderManagerMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderManagerMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &OrderManagerMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.orderID = &orderID

	return mmGetByOrderID
}

// Inspect accepts an inspector function that has same arguments as the orderManager.GetByOrderID
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Inspect(f func(ctx context.Context, orderID int64)) *mOrderManagerMockGetByOrderID {
	if mmGetByOrderID.mock.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("Inspect function is already set for OrderManagerMock.GetByOrderID")
	}

	mmGetByOrderID.mock.inspectFuncGetByOrderID = f

	return mmGetByOrderID
}

// Return sets up results that will be returned by orderManager.GetByOrderID
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Return(o1 models.Order, err error) *OrderManagerMock {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &OrderManagerMockGetByOrderIDExpectation{mock: mmGetByOrderID.mock}
	}
	mmGetByOrderID.defaultExpectation.results = &OrderManagerMockGetByOrderIDResults{o1, err}
	return mmGetByOrderID.mock
}

// Set uses given function f to mock the orderManager.GetByOrderID method
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Set(f func(ctx context.Context, orderID int64) (o1 models.Order, err error)) *OrderManagerMock {
	if mmGetByOrderID.defaultExpectation != nil {
		mmGetByOrderID.mock.t.Fatalf("Default expectation is already set for the orderManager.GetByOrderID method")
	}

	if len(mmGetByOrderID.expectations) > 0 {
		mmGetByOrderID.mock.t.Fatalf("Some expectations are already set for the orderManager.GetByOrderID method")
	}

	mmGetByOrderID.mock.funcGetByOrderID = f
	return mmGetByOrderID.mock
}

// When sets expectation for the orderManager.GetByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) When(ctx context.Context, orderID int64) *OrderManagerMockGetByOrderIDExpectation {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("OrderManagerMock.GetByOrderID mock is already set by Set")
	}

	expectation := &OrderManagerMockGetByOrderIDExpectation{
		mock:   mmGetByOrderID.mock,
		params: &OrderManagerMockGetByOrderIDParams{ctx, orderID},
	}
	mmGetByOrderID.expectations = append(mmGetByOrderID.expectations, expectation)
	return expectation
}

// Then sets up orderManager.GetByOrderID return parameters for the expectation previously defined by the When method
func (e *OrderManagerMockGetByOrderIDExpectation) Then(o1 models.Order, err error) *OrderManagerMock {
	e.results = &OrderManagerMockGetByOrderIDResults{o1, err}
	return e.mock
}

// Times sets number of times orderManager.GetByOrderID should be invoked
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Times(n uint64) *mOrderManagerMockGetByOrderID {
	if n == 0 {
		mmGetByOrderID.mock.t.Fatalf("Times of OrderManagerMock.GetByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByOrderID.expectedInvocations, n)
	return mmGetByOrderID
}

func (mmGetByOrderID *mOrderManagerMockGetByOrderID) invocationsDone() bool {
	if len(mmGetByOrderID.expectations) == 0 && mmGetByOrderID.defaultExpectation == nil && mmGetByOrderID.mock.funcGetByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.mock.afterGetByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByOrderID implements orderManager
func (mmGetByOrderID *OrderManagerMock) GetByOrderID(ctx context.Context, orderID int64) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmGetByOrderID.beforeGetByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderID.afterGetByOrderIDCounter, 1)

	if mmGetByOrderID.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.inspectFuncGetByOrderID(ctx, orderID)
	}

	mm_params := OrderManagerMockGetByOrderIDParams{ctx, orderID}

	// Record call args
	mmGetByOrderID.GetByOrderIDMock.mutex.Lock()
	mmGetByOrderID.GetByOrderIDMock.callArgs = append(mmGetByOrderID.GetByOrderIDMock.callArgs, &mm_params)
	mmGetByOrderID.GetByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetByOrderID.GetByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByOrderID.GetByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderID.GetByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := OrderManagerMockGetByOrderIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByOrderID.t.Errorf("OrderManagerMock.GetByOrderID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByOrderID.t.Errorf("OrderManagerMock.GetByOrderID got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderID.t.Errorf("OrderManagerMock.GetByOrderID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderID.t.Fatal("No results are set for the OrderManagerMock.GetByOrderID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByOrderID.funcGetByOrderID != nil {
		return mmGetByOrderID.funcGetByOrderID(ctx, orderID)
	}
	mmGetByOrderID.t.Fatalf("Unexpected call to OrderManagerMock.GetByOrderID. %v %v", ctx, orderID)
	return
}

// GetByOrderIDAfterCounter returns a count of finished OrderManagerMock.GetByOrderID invocations
func (mmGetByOrderID *OrderManagerMock) GetByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.afterGetByOrderIDCounter)
}

// GetByOrderIDBeforeCounter returns a count of OrderManagerMock.GetByOrderID invocations
func (mmGetByOrderID *OrderManagerMock) GetByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.beforeGetByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to OrderManagerMock.GetByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderID *mOrderManagerMockGetByOrderID) Calls() []*OrderManagerMockGetByOrderIDParams {
	mmGetByOrderID.mutex.RLock()

	argCopy := make([]*OrderManagerMockGetByOrderIDParams, len(mmGetByOrderID.callArgs))
	copy(argCopy, mmGetByOrderID.callArgs)

	mmGetByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDDone returns true if the count of the GetByOrderID invocations corresponds
// the number of defined expectations
func (m *OrderManagerMock) MinimockGetByOrderIDDone() bool {
	if m.GetByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByOrderIDMock.invocationsDone()
}

// MinimockGetByOrderIDInspect logs each unmet expectation
func (m *OrderManagerMock) MinimockGetByOrderIDInspect() {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderManagerMock.GetByOrderID with params: %#v", *e.params)
		}
	}

	afterGetByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && afterGetByOrderIDCounter < 1 {
		if m.GetByOrderIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderManagerMock.GetByOrderID")
		} else {
			m.t.Errorf("Expected call to OrderManagerMock.GetByOrderID with params: %#v", *m.GetByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && afterGetByOrderIDCounter < 1 {
		m.t.Error("Expected call to OrderManagerMock.GetByOrderID")
	}

	if !m.GetByOrderIDMock.invocationsDone() && afterGetByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderManagerMock.GetByOrderID but found %d calls",
			mm_atomic.LoadUint64(&m.GetByOrderIDMock.expectedInvocations), afterGetByOrderIDCounter)
	}
}

type mOrderManagerMockSetStatus struct {
	optional           bool
	mock               *OrderManagerMock
	defaultExpectation *OrderManagerMockSetStatusExpectation
	expectations       []*OrderManagerMockSetStatusExpectation

	callArgs []*OrderManagerMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderManagerMockSetStatusExpectation specifies expectation struct of the orderManager.SetStatus
type OrderManagerMockSetStatusExpectation struct {
	mock      *OrderManagerMock
	params    *OrderManagerMockSetStatusParams
	paramPtrs *OrderManagerMockSetStatusParamPtrs
	results   *OrderManagerMockSetStatusResults
	Counter   uint64
}

// OrderManagerMockSetStatusParams contains parameters of the orderManager.SetStatus
type OrderManagerMockSetStatusParams struct {
	ctx     context.Context
	orderID int64
	status  models.OrderStatus
}

// OrderManagerMockSetStatusParamPtrs contains pointers to parameters of the orderManager.SetStatus
type OrderManagerMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *int64
	status  *models.OrderStatus
}

// OrderManagerMockSetStatusResults contains results of the orderManager.SetStatus
type OrderManagerMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderManagerMockSetStatus) Optional() *mOrderManagerMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) Expect(ctx context.Context, orderID int64, status models.OrderStatus) *mOrderManagerMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderManagerMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderManagerMockSetStatusParams{ctx, orderID, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderManagerMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderManagerMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderManagerMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) ExpectOrderIDParam2(orderID int64) *mOrderManagerMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderManagerMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderManagerMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) ExpectStatusParam3(status models.OrderStatus) *mOrderManagerMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderManagerMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderManagerMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) Inspect(f func(ctx context.Context, orderID int64, status models.OrderStatus)) *mOrderManagerMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderManagerMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by orderManager.SetStatus
func (mmSetStatus *mOrderManagerMockSetStatus) Return(err error) *OrderManagerMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderManagerMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderManagerMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the orderManager.SetStatus method
func (mmSetStatus *mOrderManagerMockSetStatus) Set(f func(ctx context.Context, orderID int64, status models.OrderStatus) (err error)) *OrderManagerMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the orderManager.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the orderManager.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the orderManager.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderManagerMockSetStatus) When(ctx context.Context, orderID int64, status models.OrderStatus) *OrderManagerMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderManagerMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderManagerMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderManagerMockSetStatusParams{ctx, orderID, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up orderManager.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderManagerMockSetStatusExpectation) Then(err error) *OrderManagerMock {
	e.results = &OrderManagerMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times orderManager.SetStatus should be invoked
func (mmSetStatus *mOrderManagerMockSetStatus) Times(n uint64) *mOrderManagerMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderManagerMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderManagerMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements orderManager
func (mmSetStatus *OrderManagerMock) SetStatus(ctx context.Context, orderID int64, status models.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := OrderManagerMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderManagerMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderManagerMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("OrderManagerMock.SetStatus got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderManagerMock.SetStatus got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderManagerMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderManagerMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderManagerMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderManagerMock.SetStatus invocations
func (mmSetStatus *OrderManagerMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderManagerMock.SetStatus invocations
func (mmSetStatus *OrderManagerMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderManagerMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderManagerMockSetStatus) Calls() []*OrderManagerMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderManagerMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderManagerMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderManagerMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderManagerMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderManagerMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderManagerMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderManagerMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderManagerMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByOrderIDInspect()

			m.MinimockSetStatusInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByOrderIDDone() &&
		m.MinimockSetStatusDone()
}
