// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package usecase_test

//go:generate minimock -i route256/loms/internal/loms/usecase.stockProvider -o stock_provider_mock_test.go -n StockProviderMock -p usecase_test

import (
	"context"
	"route256/loms/internal/loms/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StockProviderMock implements stockProvider
type StockProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, skuID uint32) (i1 int64, err error)
	inspectFuncGetBySKU   func(ctx context.Context, skuID uint32)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mStockProviderMockGetBySKU

	funcReserve          func(ctx context.Context, order models.Order) (err error)
	inspectFuncReserve   func(ctx context.Context, order models.Order)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStockProviderMockReserve

	funcReserveCancel          func(ctx context.Context, order models.Order) (err error)
	inspectFuncReserveCancel   func(ctx context.Context, order models.Order)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStockProviderMockReserveCancel

	funcReserveRemove          func(ctx context.Context, order models.Order) (err error)
	inspectFuncReserveRemove   func(ctx context.Context, order models.Order)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStockProviderMockReserveRemove
}

// NewStockProviderMock returns a mock for stockProvider
func NewStockProviderMock(t minimock.Tester) *StockProviderMock {
	m := &StockProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mStockProviderMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*StockProviderMockGetBySKUParams{}

	m.ReserveMock = mStockProviderMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StockProviderMockReserveParams{}

	m.ReserveCancelMock = mStockProviderMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StockProviderMockReserveCancelParams{}

	m.ReserveRemoveMock = mStockProviderMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StockProviderMockReserveRemoveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStockProviderMockGetBySKU struct {
	optional           bool
	mock               *StockProviderMock
	defaultExpectation *StockProviderMockGetBySKUExpectation
	expectations       []*StockProviderMockGetBySKUExpectation

	callArgs []*StockProviderMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockProviderMockGetBySKUExpectation specifies expectation struct of the stockProvider.GetBySKU
type StockProviderMockGetBySKUExpectation struct {
	mock      *StockProviderMock
	params    *StockProviderMockGetBySKUParams
	paramPtrs *StockProviderMockGetBySKUParamPtrs
	results   *StockProviderMockGetBySKUResults
	Counter   uint64
}

// StockProviderMockGetBySKUParams contains parameters of the stockProvider.GetBySKU
type StockProviderMockGetBySKUParams struct {
	ctx   context.Context
	skuID uint32
}

// StockProviderMockGetBySKUParamPtrs contains pointers to parameters of the stockProvider.GetBySKU
type StockProviderMockGetBySKUParamPtrs struct {
	ctx   *context.Context
	skuID *uint32
}

// StockProviderMockGetBySKUResults contains results of the stockProvider.GetBySKU
type StockProviderMockGetBySKUResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mStockProviderMockGetBySKU) Optional() *mStockProviderMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for stockProvider.GetBySKU
func (mmGetBySKU *mStockProviderMockGetBySKU) Expect(ctx context.Context, skuID uint32) *mStockProviderMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockProviderMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &StockProviderMockGetBySKUParams{ctx, skuID}
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for stockProvider.GetBySKU
func (mmGetBySKU *mStockProviderMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mStockProviderMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockProviderMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockProviderMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetBySKU
}

// ExpectSkuIDParam2 sets up expected param skuID for stockProvider.GetBySKU
func (mmGetBySKU *mStockProviderMockGetBySKU) ExpectSkuIDParam2(skuID uint32) *mStockProviderMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockProviderMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StockProviderMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.skuID = &skuID

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the stockProvider.GetBySKU
func (mmGetBySKU *mStockProviderMockGetBySKU) Inspect(f func(ctx context.Context, skuID uint32)) *mStockProviderMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for StockProviderMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by stockProvider.GetBySKU
func (mmGetBySKU *mStockProviderMockGetBySKU) Return(i1 int64, err error) *StockProviderMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StockProviderMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &StockProviderMockGetBySKUResults{i1, err}
	return mmGetBySKU.mock
}

// Set uses given function f to mock the stockProvider.GetBySKU method
func (mmGetBySKU *mStockProviderMockGetBySKU) Set(f func(ctx context.Context, skuID uint32) (i1 int64, err error)) *StockProviderMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the stockProvider.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the stockProvider.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	return mmGetBySKU.mock
}

// When sets expectation for the stockProvider.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mStockProviderMockGetBySKU) When(ctx context.Context, skuID uint32) *StockProviderMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StockProviderMock.GetBySKU mock is already set by Set")
	}

	expectation := &StockProviderMockGetBySKUExpectation{
		mock:   mmGetBySKU.mock,
		params: &StockProviderMockGetBySKUParams{ctx, skuID},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up stockProvider.GetBySKU return parameters for the expectation previously defined by the When method
func (e *StockProviderMockGetBySKUExpectation) Then(i1 int64, err error) *StockProviderMock {
	e.results = &StockProviderMockGetBySKUResults{i1, err}
	return e.mock
}

// Times sets number of times stockProvider.GetBySKU should be invoked
func (mmGetBySKU *mStockProviderMockGetBySKU) Times(n uint64) *mStockProviderMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of StockProviderMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	return mmGetBySKU
}

func (mmGetBySKU *mStockProviderMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements stockProvider
func (mmGetBySKU *StockProviderMock) GetBySKU(ctx context.Context, skuID uint32) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, skuID)
	}

	mm_params := StockProviderMockGetBySKUParams{ctx, skuID}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StockProviderMockGetBySKUParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("StockProviderMock.GetBySKU got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetBySKU.t.Errorf("StockProviderMock.GetBySKU got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("StockProviderMock.GetBySKU got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the StockProviderMock.GetBySKU")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, skuID)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to StockProviderMock.GetBySKU. %v %v", ctx, skuID)
	return
}

// GetBySKUAfterCounter returns a count of finished StockProviderMock.GetBySKU invocations
func (mmGetBySKU *StockProviderMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of StockProviderMock.GetBySKU invocations
func (mmGetBySKU *StockProviderMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StockProviderMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mStockProviderMockGetBySKU) Calls() []*StockProviderMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*StockProviderMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *StockProviderMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *StockProviderMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockProviderMock.GetBySKU with params: %#v", *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockProviderMock.GetBySKU")
		} else {
			m.t.Errorf("Expected call to StockProviderMock.GetBySKU with params: %#v", *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Error("Expected call to StockProviderMock.GetBySKU")
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StockProviderMock.GetBySKU but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), afterGetBySKUCounter)
	}
}

type mStockProviderMockReserve struct {
	optional           bool
	mock               *StockProviderMock
	defaultExpectation *StockProviderMockReserveExpectation
	expectations       []*StockProviderMockReserveExpectation

	callArgs []*StockProviderMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockProviderMockReserveExpectation specifies expectation struct of the stockProvider.Reserve
type StockProviderMockReserveExpectation struct {
	mock      *StockProviderMock
	params    *StockProviderMockReserveParams
	paramPtrs *StockProviderMockReserveParamPtrs
	results   *StockProviderMockReserveResults
	Counter   uint64
}

// StockProviderMockReserveParams contains parameters of the stockProvider.Reserve
type StockProviderMockReserveParams struct {
	ctx   context.Context
	order models.Order
}

// StockProviderMockReserveParamPtrs contains pointers to parameters of the stockProvider.Reserve
type StockProviderMockReserveParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// StockProviderMockReserveResults contains results of the stockProvider.Reserve
type StockProviderMockReserveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStockProviderMockReserve) Optional() *mStockProviderMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for stockProvider.Reserve
func (mmReserve *mStockProviderMockReserve) Expect(ctx context.Context, order models.Order) *mStockProviderMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockProviderMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StockProviderMockReserveParams{ctx, order}
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for stockProvider.Reserve
func (mmReserve *mStockProviderMockReserve) ExpectCtxParam1(ctx context.Context) *mStockProviderMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockProviderMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockProviderMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserve
}

// ExpectOrderParam2 sets up expected param order for stockProvider.Reserve
func (mmReserve *mStockProviderMockReserve) ExpectOrderParam2(order models.Order) *mStockProviderMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockProviderMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StockProviderMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.order = &order

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the stockProvider.Reserve
func (mmReserve *mStockProviderMockReserve) Inspect(f func(ctx context.Context, order models.Order)) *mStockProviderMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StockProviderMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by stockProvider.Reserve
func (mmReserve *mStockProviderMockReserve) Return(err error) *StockProviderMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StockProviderMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StockProviderMockReserveResults{err}
	return mmReserve.mock
}

// Set uses given function f to mock the stockProvider.Reserve method
func (mmReserve *mStockProviderMockReserve) Set(f func(ctx context.Context, order models.Order) (err error)) *StockProviderMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the stockProvider.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the stockProvider.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	return mmReserve.mock
}

// When sets expectation for the stockProvider.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStockProviderMockReserve) When(ctx context.Context, order models.Order) *StockProviderMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StockProviderMock.Reserve mock is already set by Set")
	}

	expectation := &StockProviderMockReserveExpectation{
		mock:   mmReserve.mock,
		params: &StockProviderMockReserveParams{ctx, order},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up stockProvider.Reserve return parameters for the expectation previously defined by the When method
func (e *StockProviderMockReserveExpectation) Then(err error) *StockProviderMock {
	e.results = &StockProviderMockReserveResults{err}
	return e.mock
}

// Times sets number of times stockProvider.Reserve should be invoked
func (mmReserve *mStockProviderMockReserve) Times(n uint64) *mStockProviderMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StockProviderMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	return mmReserve
}

func (mmReserve *mStockProviderMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements stockProvider
func (mmReserve *StockProviderMock) Reserve(ctx context.Context, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, order)
	}

	mm_params := StockProviderMockReserveParams{ctx, order}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StockProviderMockReserveParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StockProviderMock.Reserve got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmReserve.t.Errorf("StockProviderMock.Reserve got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StockProviderMock.Reserve got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StockProviderMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, order)
	}
	mmReserve.t.Fatalf("Unexpected call to StockProviderMock.Reserve. %v %v", ctx, order)
	return
}

// ReserveAfterCounter returns a count of finished StockProviderMock.Reserve invocations
func (mmReserve *StockProviderMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StockProviderMock.Reserve invocations
func (mmReserve *StockProviderMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StockProviderMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStockProviderMockReserve) Calls() []*StockProviderMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StockProviderMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StockProviderMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StockProviderMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockProviderMock.Reserve with params: %#v", *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockProviderMock.Reserve")
		} else {
			m.t.Errorf("Expected call to StockProviderMock.Reserve with params: %#v", *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Error("Expected call to StockProviderMock.Reserve")
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockProviderMock.Reserve but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), afterReserveCounter)
	}
}

type mStockProviderMockReserveCancel struct {
	optional           bool
	mock               *StockProviderMock
	defaultExpectation *StockProviderMockReserveCancelExpectation
	expectations       []*StockProviderMockReserveCancelExpectation

	callArgs []*StockProviderMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockProviderMockReserveCancelExpectation specifies expectation struct of the stockProvider.ReserveCancel
type StockProviderMockReserveCancelExpectation struct {
	mock      *StockProviderMock
	params    *StockProviderMockReserveCancelParams
	paramPtrs *StockProviderMockReserveCancelParamPtrs
	results   *StockProviderMockReserveCancelResults
	Counter   uint64
}

// StockProviderMockReserveCancelParams contains parameters of the stockProvider.ReserveCancel
type StockProviderMockReserveCancelParams struct {
	ctx   context.Context
	order models.Order
}

// StockProviderMockReserveCancelParamPtrs contains pointers to parameters of the stockProvider.ReserveCancel
type StockProviderMockReserveCancelParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// StockProviderMockReserveCancelResults contains results of the stockProvider.ReserveCancel
type StockProviderMockReserveCancelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStockProviderMockReserveCancel) Optional() *mStockProviderMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for stockProvider.ReserveCancel
func (mmReserveCancel *mStockProviderMockReserveCancel) Expect(ctx context.Context, order models.Order) *mStockProviderMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockProviderMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StockProviderMockReserveCancelParams{ctx, order}
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for stockProvider.ReserveCancel
func (mmReserveCancel *mStockProviderMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStockProviderMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockProviderMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockProviderMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveCancel
}

// ExpectOrderParam2 sets up expected param order for stockProvider.ReserveCancel
func (mmReserveCancel *mStockProviderMockReserveCancel) ExpectOrderParam2(order models.Order) *mStockProviderMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockProviderMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StockProviderMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.order = &order

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the stockProvider.ReserveCancel
func (mmReserveCancel *mStockProviderMockReserveCancel) Inspect(f func(ctx context.Context, order models.Order)) *mStockProviderMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StockProviderMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by stockProvider.ReserveCancel
func (mmReserveCancel *mStockProviderMockReserveCancel) Return(err error) *StockProviderMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StockProviderMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StockProviderMockReserveCancelResults{err}
	return mmReserveCancel.mock
}

// Set uses given function f to mock the stockProvider.ReserveCancel method
func (mmReserveCancel *mStockProviderMockReserveCancel) Set(f func(ctx context.Context, order models.Order) (err error)) *StockProviderMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the stockProvider.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the stockProvider.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	return mmReserveCancel.mock
}

// When sets expectation for the stockProvider.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStockProviderMockReserveCancel) When(ctx context.Context, order models.Order) *StockProviderMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StockProviderMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StockProviderMockReserveCancelExpectation{
		mock:   mmReserveCancel.mock,
		params: &StockProviderMockReserveCancelParams{ctx, order},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up stockProvider.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StockProviderMockReserveCancelExpectation) Then(err error) *StockProviderMock {
	e.results = &StockProviderMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times stockProvider.ReserveCancel should be invoked
func (mmReserveCancel *mStockProviderMockReserveCancel) Times(n uint64) *mStockProviderMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StockProviderMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	return mmReserveCancel
}

func (mmReserveCancel *mStockProviderMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements stockProvider
func (mmReserveCancel *StockProviderMock) ReserveCancel(ctx context.Context, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, order)
	}

	mm_params := StockProviderMockReserveCancelParams{ctx, order}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StockProviderMockReserveCancelParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StockProviderMock.ReserveCancel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmReserveCancel.t.Errorf("StockProviderMock.ReserveCancel got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StockProviderMock.ReserveCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StockProviderMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, order)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StockProviderMock.ReserveCancel. %v %v", ctx, order)
	return
}

// ReserveCancelAfterCounter returns a count of finished StockProviderMock.ReserveCancel invocations
func (mmReserveCancel *StockProviderMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StockProviderMock.ReserveCancel invocations
func (mmReserveCancel *StockProviderMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StockProviderMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStockProviderMockReserveCancel) Calls() []*StockProviderMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StockProviderMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StockProviderMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StockProviderMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockProviderMock.ReserveCancel with params: %#v", *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockProviderMock.ReserveCancel")
		} else {
			m.t.Errorf("Expected call to StockProviderMock.ReserveCancel with params: %#v", *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Error("Expected call to StockProviderMock.ReserveCancel")
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StockProviderMock.ReserveCancel but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), afterReserveCancelCounter)
	}
}

type mStockProviderMockReserveRemove struct {
	optional           bool
	mock               *StockProviderMock
	defaultExpectation *StockProviderMockReserveRemoveExpectation
	expectations       []*StockProviderMockReserveRemoveExpectation

	callArgs []*StockProviderMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// StockProviderMockReserveRemoveExpectation specifies expectation struct of the stockProvider.ReserveRemove
type StockProviderMockReserveRemoveExpectation struct {
	mock      *StockProviderMock
	params    *StockProviderMockReserveRemoveParams
	paramPtrs *StockProviderMockReserveRemoveParamPtrs
	results   *StockProviderMockReserveRemoveResults
	Counter   uint64
}

// StockProviderMockReserveRemoveParams contains parameters of the stockProvider.ReserveRemove
type StockProviderMockReserveRemoveParams struct {
	ctx   context.Context
	order models.Order
}

// StockProviderMockReserveRemoveParamPtrs contains pointers to parameters of the stockProvider.ReserveRemove
type StockProviderMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// StockProviderMockReserveRemoveResults contains results of the stockProvider.ReserveRemove
type StockProviderMockReserveRemoveResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStockProviderMockReserveRemove) Optional() *mStockProviderMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for stockProvider.ReserveRemove
func (mmReserveRemove *mStockProviderMockReserveRemove) Expect(ctx context.Context, order models.Order) *mStockProviderMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockProviderMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StockProviderMockReserveRemoveParams{ctx, order}
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for stockProvider.ReserveRemove
func (mmReserveRemove *mStockProviderMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStockProviderMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockProviderMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockProviderMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx

	return mmReserveRemove
}

// ExpectOrderParam2 sets up expected param order for stockProvider.ReserveRemove
func (mmReserveRemove *mStockProviderMockReserveRemove) ExpectOrderParam2(order models.Order) *mStockProviderMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockProviderMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StockProviderMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.order = &order

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the stockProvider.ReserveRemove
func (mmReserveRemove *mStockProviderMockReserveRemove) Inspect(f func(ctx context.Context, order models.Order)) *mStockProviderMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StockProviderMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by stockProvider.ReserveRemove
func (mmReserveRemove *mStockProviderMockReserveRemove) Return(err error) *StockProviderMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StockProviderMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StockProviderMockReserveRemoveResults{err}
	return mmReserveRemove.mock
}

// Set uses given function f to mock the stockProvider.ReserveRemove method
func (mmReserveRemove *mStockProviderMockReserveRemove) Set(f func(ctx context.Context, order models.Order) (err error)) *StockProviderMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the stockProvider.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the stockProvider.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	return mmReserveRemove.mock
}

// When sets expectation for the stockProvider.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStockProviderMockReserveRemove) When(ctx context.Context, order models.Order) *StockProviderMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StockProviderMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StockProviderMockReserveRemoveExpectation{
		mock:   mmReserveRemove.mock,
		params: &StockProviderMockReserveRemoveParams{ctx, order},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up stockProvider.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StockProviderMockReserveRemoveExpectation) Then(err error) *StockProviderMock {
	e.results = &StockProviderMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times stockProvider.ReserveRemove should be invoked
func (mmReserveRemove *mStockProviderMockReserveRemove) Times(n uint64) *mStockProviderMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StockProviderMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	return mmReserveRemove
}

func (mmReserveRemove *mStockProviderMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements stockProvider
func (mmReserveRemove *StockProviderMock) ReserveRemove(ctx context.Context, order models.Order) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, order)
	}

	mm_params := StockProviderMockReserveRemoveParams{ctx, order}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StockProviderMockReserveRemoveParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StockProviderMock.ReserveRemove got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmReserveRemove.t.Errorf("StockProviderMock.ReserveRemove got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StockProviderMock.ReserveRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StockProviderMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, order)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StockProviderMock.ReserveRemove. %v %v", ctx, order)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StockProviderMock.ReserveRemove invocations
func (mmReserveRemove *StockProviderMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StockProviderMock.ReserveRemove invocations
func (mmReserveRemove *StockProviderMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StockProviderMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStockProviderMockReserveRemove) Calls() []*StockProviderMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StockProviderMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StockProviderMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StockProviderMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StockProviderMock.ReserveRemove with params: %#v", *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StockProviderMock.ReserveRemove")
		} else {
			m.t.Errorf("Expected call to StockProviderMock.ReserveRemove with params: %#v", *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Error("Expected call to StockProviderMock.ReserveRemove")
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StockProviderMock.ReserveRemove but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), afterReserveRemoveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StockProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StockProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StockProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone()
}
