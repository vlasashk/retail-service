// Code generated by http://github.com/gojuno/minimock (v3.3.11). DO NOT EDIT.

package impl_test

//go:generate minimock -i route256/loms/internal/loms/ports/ggrpc/impl.lomsServer -o loms_server_mock_test.go -n LomsServerMock -p impl_test

import (
	"context"
	"route256/loms/internal/loms/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LomsServerMock implements lomsServer
type LomsServerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOrderCancel          func(ctx context.Context, orderID int64) (err error)
	inspectFuncOrderCancel   func(ctx context.Context, orderID int64)
	afterOrderCancelCounter  uint64
	beforeOrderCancelCounter uint64
	OrderCancelMock          mLomsServerMockOrderCancel

	funcOrderCreate          func(ctx context.Context, order models.Order) (i1 int64, err error)
	inspectFuncOrderCreate   func(ctx context.Context, order models.Order)
	afterOrderCreateCounter  uint64
	beforeOrderCreateCounter uint64
	OrderCreateMock          mLomsServerMockOrderCreate

	funcOrderInfo          func(ctx context.Context, orderID int64) (o1 models.Order, err error)
	inspectFuncOrderInfo   func(ctx context.Context, orderID int64)
	afterOrderInfoCounter  uint64
	beforeOrderInfoCounter uint64
	OrderInfoMock          mLomsServerMockOrderInfo

	funcOrderPay          func(ctx context.Context, orderID int64) (err error)
	inspectFuncOrderPay   func(ctx context.Context, orderID int64)
	afterOrderPayCounter  uint64
	beforeOrderPayCounter uint64
	OrderPayMock          mLomsServerMockOrderPay

	funcStocksInfo          func(ctx context.Context, skuID uint32) (i1 int64, err error)
	inspectFuncStocksInfo   func(ctx context.Context, skuID uint32)
	afterStocksInfoCounter  uint64
	beforeStocksInfoCounter uint64
	StocksInfoMock          mLomsServerMockStocksInfo
}

// NewLomsServerMock returns a mock for lomsServer
func NewLomsServerMock(t minimock.Tester) *LomsServerMock {
	m := &LomsServerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OrderCancelMock = mLomsServerMockOrderCancel{mock: m}
	m.OrderCancelMock.callArgs = []*LomsServerMockOrderCancelParams{}

	m.OrderCreateMock = mLomsServerMockOrderCreate{mock: m}
	m.OrderCreateMock.callArgs = []*LomsServerMockOrderCreateParams{}

	m.OrderInfoMock = mLomsServerMockOrderInfo{mock: m}
	m.OrderInfoMock.callArgs = []*LomsServerMockOrderInfoParams{}

	m.OrderPayMock = mLomsServerMockOrderPay{mock: m}
	m.OrderPayMock.callArgs = []*LomsServerMockOrderPayParams{}

	m.StocksInfoMock = mLomsServerMockStocksInfo{mock: m}
	m.StocksInfoMock.callArgs = []*LomsServerMockStocksInfoParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLomsServerMockOrderCancel struct {
	optional           bool
	mock               *LomsServerMock
	defaultExpectation *LomsServerMockOrderCancelExpectation
	expectations       []*LomsServerMockOrderCancelExpectation

	callArgs []*LomsServerMockOrderCancelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServerMockOrderCancelExpectation specifies expectation struct of the lomsServer.OrderCancel
type LomsServerMockOrderCancelExpectation struct {
	mock      *LomsServerMock
	params    *LomsServerMockOrderCancelParams
	paramPtrs *LomsServerMockOrderCancelParamPtrs
	results   *LomsServerMockOrderCancelResults
	Counter   uint64
}

// LomsServerMockOrderCancelParams contains parameters of the lomsServer.OrderCancel
type LomsServerMockOrderCancelParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServerMockOrderCancelParamPtrs contains pointers to parameters of the lomsServer.OrderCancel
type LomsServerMockOrderCancelParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServerMockOrderCancelResults contains results of the lomsServer.OrderCancel
type LomsServerMockOrderCancelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCancel *mLomsServerMockOrderCancel) Optional() *mLomsServerMockOrderCancel {
	mmOrderCancel.optional = true
	return mmOrderCancel
}

// Expect sets up expected params for lomsServer.OrderCancel
func (mmOrderCancel *mLomsServerMockOrderCancel) Expect(ctx context.Context, orderID int64) *mLomsServerMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServerMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.paramPtrs != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by ExpectParams functions")
	}

	mmOrderCancel.defaultExpectation.params = &LomsServerMockOrderCancelParams{ctx, orderID}
	for _, e := range mmOrderCancel.expectations {
		if minimock.Equal(e.params, mmOrderCancel.defaultExpectation.params) {
			mmOrderCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCancel.defaultExpectation.params)
		}
	}

	return mmOrderCancel
}

// ExpectCtxParam1 sets up expected param ctx for lomsServer.OrderCancel
func (mmOrderCancel *mLomsServerMockOrderCancel) ExpectCtxParam1(ctx context.Context) *mLomsServerMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServerMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServerMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderCancel
}

// ExpectOrderIDParam2 sets up expected param orderID for lomsServer.OrderCancel
func (mmOrderCancel *mLomsServerMockOrderCancel) ExpectOrderIDParam2(orderID int64) *mLomsServerMockOrderCancel {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServerMockOrderCancelExpectation{}
	}

	if mmOrderCancel.defaultExpectation.params != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Expect")
	}

	if mmOrderCancel.defaultExpectation.paramPtrs == nil {
		mmOrderCancel.defaultExpectation.paramPtrs = &LomsServerMockOrderCancelParamPtrs{}
	}
	mmOrderCancel.defaultExpectation.paramPtrs.orderID = &orderID

	return mmOrderCancel
}

// Inspect accepts an inspector function that has same arguments as the lomsServer.OrderCancel
func (mmOrderCancel *mLomsServerMockOrderCancel) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServerMockOrderCancel {
	if mmOrderCancel.mock.inspectFuncOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("Inspect function is already set for LomsServerMock.OrderCancel")
	}

	mmOrderCancel.mock.inspectFuncOrderCancel = f

	return mmOrderCancel
}

// Return sets up results that will be returned by lomsServer.OrderCancel
func (mmOrderCancel *mLomsServerMockOrderCancel) Return(err error) *LomsServerMock {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Set")
	}

	if mmOrderCancel.defaultExpectation == nil {
		mmOrderCancel.defaultExpectation = &LomsServerMockOrderCancelExpectation{mock: mmOrderCancel.mock}
	}
	mmOrderCancel.defaultExpectation.results = &LomsServerMockOrderCancelResults{err}
	return mmOrderCancel.mock
}

// Set uses given function f to mock the lomsServer.OrderCancel method
func (mmOrderCancel *mLomsServerMockOrderCancel) Set(f func(ctx context.Context, orderID int64) (err error)) *LomsServerMock {
	if mmOrderCancel.defaultExpectation != nil {
		mmOrderCancel.mock.t.Fatalf("Default expectation is already set for the lomsServer.OrderCancel method")
	}

	if len(mmOrderCancel.expectations) > 0 {
		mmOrderCancel.mock.t.Fatalf("Some expectations are already set for the lomsServer.OrderCancel method")
	}

	mmOrderCancel.mock.funcOrderCancel = f
	return mmOrderCancel.mock
}

// When sets expectation for the lomsServer.OrderCancel which will trigger the result defined by the following
// Then helper
func (mmOrderCancel *mLomsServerMockOrderCancel) When(ctx context.Context, orderID int64) *LomsServerMockOrderCancelExpectation {
	if mmOrderCancel.mock.funcOrderCancel != nil {
		mmOrderCancel.mock.t.Fatalf("LomsServerMock.OrderCancel mock is already set by Set")
	}

	expectation := &LomsServerMockOrderCancelExpectation{
		mock:   mmOrderCancel.mock,
		params: &LomsServerMockOrderCancelParams{ctx, orderID},
	}
	mmOrderCancel.expectations = append(mmOrderCancel.expectations, expectation)
	return expectation
}

// Then sets up lomsServer.OrderCancel return parameters for the expectation previously defined by the When method
func (e *LomsServerMockOrderCancelExpectation) Then(err error) *LomsServerMock {
	e.results = &LomsServerMockOrderCancelResults{err}
	return e.mock
}

// Times sets number of times lomsServer.OrderCancel should be invoked
func (mmOrderCancel *mLomsServerMockOrderCancel) Times(n uint64) *mLomsServerMockOrderCancel {
	if n == 0 {
		mmOrderCancel.mock.t.Fatalf("Times of LomsServerMock.OrderCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCancel.expectedInvocations, n)
	return mmOrderCancel
}

func (mmOrderCancel *mLomsServerMockOrderCancel) invocationsDone() bool {
	if len(mmOrderCancel.expectations) == 0 && mmOrderCancel.defaultExpectation == nil && mmOrderCancel.mock.funcOrderCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCancel.mock.afterOrderCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCancel implements lomsServer
func (mmOrderCancel *LomsServerMock) OrderCancel(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmOrderCancel.beforeOrderCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCancel.afterOrderCancelCounter, 1)

	if mmOrderCancel.inspectFuncOrderCancel != nil {
		mmOrderCancel.inspectFuncOrderCancel(ctx, orderID)
	}

	mm_params := LomsServerMockOrderCancelParams{ctx, orderID}

	// Record call args
	mmOrderCancel.OrderCancelMock.mutex.Lock()
	mmOrderCancel.OrderCancelMock.callArgs = append(mmOrderCancel.OrderCancelMock.callArgs, &mm_params)
	mmOrderCancel.OrderCancelMock.mutex.Unlock()

	for _, e := range mmOrderCancel.OrderCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderCancel.OrderCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCancel.OrderCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCancel.OrderCancelMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCancel.OrderCancelMock.defaultExpectation.paramPtrs

		mm_got := LomsServerMockOrderCancelParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCancel.t.Errorf("LomsServerMock.OrderCancel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderCancel.t.Errorf("LomsServerMock.OrderCancel got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCancel.t.Errorf("LomsServerMock.OrderCancel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCancel.OrderCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCancel.t.Fatal("No results are set for the LomsServerMock.OrderCancel")
		}
		return (*mm_results).err
	}
	if mmOrderCancel.funcOrderCancel != nil {
		return mmOrderCancel.funcOrderCancel(ctx, orderID)
	}
	mmOrderCancel.t.Fatalf("Unexpected call to LomsServerMock.OrderCancel. %v %v", ctx, orderID)
	return
}

// OrderCancelAfterCounter returns a count of finished LomsServerMock.OrderCancel invocations
func (mmOrderCancel *LomsServerMock) OrderCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.afterOrderCancelCounter)
}

// OrderCancelBeforeCounter returns a count of LomsServerMock.OrderCancel invocations
func (mmOrderCancel *LomsServerMock) OrderCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCancel.beforeOrderCancelCounter)
}

// Calls returns a list of arguments used in each call to LomsServerMock.OrderCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCancel *mLomsServerMockOrderCancel) Calls() []*LomsServerMockOrderCancelParams {
	mmOrderCancel.mutex.RLock()

	argCopy := make([]*LomsServerMockOrderCancelParams, len(mmOrderCancel.callArgs))
	copy(argCopy, mmOrderCancel.callArgs)

	mmOrderCancel.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCancelDone returns true if the count of the OrderCancel invocations corresponds
// the number of defined expectations
func (m *LomsServerMock) MinimockOrderCancelDone() bool {
	if m.OrderCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCancelMock.invocationsDone()
}

// MinimockOrderCancelInspect logs each unmet expectation
func (m *LomsServerMock) MinimockOrderCancelInspect() {
	for _, e := range m.OrderCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServerMock.OrderCancel with params: %#v", *e.params)
		}
	}

	afterOrderCancelCounter := mm_atomic.LoadUint64(&m.afterOrderCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCancelMock.defaultExpectation != nil && afterOrderCancelCounter < 1 {
		if m.OrderCancelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServerMock.OrderCancel")
		} else {
			m.t.Errorf("Expected call to LomsServerMock.OrderCancel with params: %#v", *m.OrderCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCancel != nil && afterOrderCancelCounter < 1 {
		m.t.Error("Expected call to LomsServerMock.OrderCancel")
	}

	if !m.OrderCancelMock.invocationsDone() && afterOrderCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServerMock.OrderCancel but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCancelMock.expectedInvocations), afterOrderCancelCounter)
	}
}

type mLomsServerMockOrderCreate struct {
	optional           bool
	mock               *LomsServerMock
	defaultExpectation *LomsServerMockOrderCreateExpectation
	expectations       []*LomsServerMockOrderCreateExpectation

	callArgs []*LomsServerMockOrderCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServerMockOrderCreateExpectation specifies expectation struct of the lomsServer.OrderCreate
type LomsServerMockOrderCreateExpectation struct {
	mock      *LomsServerMock
	params    *LomsServerMockOrderCreateParams
	paramPtrs *LomsServerMockOrderCreateParamPtrs
	results   *LomsServerMockOrderCreateResults
	Counter   uint64
}

// LomsServerMockOrderCreateParams contains parameters of the lomsServer.OrderCreate
type LomsServerMockOrderCreateParams struct {
	ctx   context.Context
	order models.Order
}

// LomsServerMockOrderCreateParamPtrs contains pointers to parameters of the lomsServer.OrderCreate
type LomsServerMockOrderCreateParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// LomsServerMockOrderCreateResults contains results of the lomsServer.OrderCreate
type LomsServerMockOrderCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderCreate *mLomsServerMockOrderCreate) Optional() *mLomsServerMockOrderCreate {
	mmOrderCreate.optional = true
	return mmOrderCreate
}

// Expect sets up expected params for lomsServer.OrderCreate
func (mmOrderCreate *mLomsServerMockOrderCreate) Expect(ctx context.Context, order models.Order) *mLomsServerMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServerMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.paramPtrs != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by ExpectParams functions")
	}

	mmOrderCreate.defaultExpectation.params = &LomsServerMockOrderCreateParams{ctx, order}
	for _, e := range mmOrderCreate.expectations {
		if minimock.Equal(e.params, mmOrderCreate.defaultExpectation.params) {
			mmOrderCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderCreate.defaultExpectation.params)
		}
	}

	return mmOrderCreate
}

// ExpectCtxParam1 sets up expected param ctx for lomsServer.OrderCreate
func (mmOrderCreate *mLomsServerMockOrderCreate) ExpectCtxParam1(ctx context.Context) *mLomsServerMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServerMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServerMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderCreate
}

// ExpectOrderParam2 sets up expected param order for lomsServer.OrderCreate
func (mmOrderCreate *mLomsServerMockOrderCreate) ExpectOrderParam2(order models.Order) *mLomsServerMockOrderCreate {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServerMockOrderCreateExpectation{}
	}

	if mmOrderCreate.defaultExpectation.params != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Expect")
	}

	if mmOrderCreate.defaultExpectation.paramPtrs == nil {
		mmOrderCreate.defaultExpectation.paramPtrs = &LomsServerMockOrderCreateParamPtrs{}
	}
	mmOrderCreate.defaultExpectation.paramPtrs.order = &order

	return mmOrderCreate
}

// Inspect accepts an inspector function that has same arguments as the lomsServer.OrderCreate
func (mmOrderCreate *mLomsServerMockOrderCreate) Inspect(f func(ctx context.Context, order models.Order)) *mLomsServerMockOrderCreate {
	if mmOrderCreate.mock.inspectFuncOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("Inspect function is already set for LomsServerMock.OrderCreate")
	}

	mmOrderCreate.mock.inspectFuncOrderCreate = f

	return mmOrderCreate
}

// Return sets up results that will be returned by lomsServer.OrderCreate
func (mmOrderCreate *mLomsServerMockOrderCreate) Return(i1 int64, err error) *LomsServerMock {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Set")
	}

	if mmOrderCreate.defaultExpectation == nil {
		mmOrderCreate.defaultExpectation = &LomsServerMockOrderCreateExpectation{mock: mmOrderCreate.mock}
	}
	mmOrderCreate.defaultExpectation.results = &LomsServerMockOrderCreateResults{i1, err}
	return mmOrderCreate.mock
}

// Set uses given function f to mock the lomsServer.OrderCreate method
func (mmOrderCreate *mLomsServerMockOrderCreate) Set(f func(ctx context.Context, order models.Order) (i1 int64, err error)) *LomsServerMock {
	if mmOrderCreate.defaultExpectation != nil {
		mmOrderCreate.mock.t.Fatalf("Default expectation is already set for the lomsServer.OrderCreate method")
	}

	if len(mmOrderCreate.expectations) > 0 {
		mmOrderCreate.mock.t.Fatalf("Some expectations are already set for the lomsServer.OrderCreate method")
	}

	mmOrderCreate.mock.funcOrderCreate = f
	return mmOrderCreate.mock
}

// When sets expectation for the lomsServer.OrderCreate which will trigger the result defined by the following
// Then helper
func (mmOrderCreate *mLomsServerMockOrderCreate) When(ctx context.Context, order models.Order) *LomsServerMockOrderCreateExpectation {
	if mmOrderCreate.mock.funcOrderCreate != nil {
		mmOrderCreate.mock.t.Fatalf("LomsServerMock.OrderCreate mock is already set by Set")
	}

	expectation := &LomsServerMockOrderCreateExpectation{
		mock:   mmOrderCreate.mock,
		params: &LomsServerMockOrderCreateParams{ctx, order},
	}
	mmOrderCreate.expectations = append(mmOrderCreate.expectations, expectation)
	return expectation
}

// Then sets up lomsServer.OrderCreate return parameters for the expectation previously defined by the When method
func (e *LomsServerMockOrderCreateExpectation) Then(i1 int64, err error) *LomsServerMock {
	e.results = &LomsServerMockOrderCreateResults{i1, err}
	return e.mock
}

// Times sets number of times lomsServer.OrderCreate should be invoked
func (mmOrderCreate *mLomsServerMockOrderCreate) Times(n uint64) *mLomsServerMockOrderCreate {
	if n == 0 {
		mmOrderCreate.mock.t.Fatalf("Times of LomsServerMock.OrderCreate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderCreate.expectedInvocations, n)
	return mmOrderCreate
}

func (mmOrderCreate *mLomsServerMockOrderCreate) invocationsDone() bool {
	if len(mmOrderCreate.expectations) == 0 && mmOrderCreate.defaultExpectation == nil && mmOrderCreate.mock.funcOrderCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderCreate.mock.afterOrderCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderCreate implements lomsServer
func (mmOrderCreate *LomsServerMock) OrderCreate(ctx context.Context, order models.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmOrderCreate.beforeOrderCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderCreate.afterOrderCreateCounter, 1)

	if mmOrderCreate.inspectFuncOrderCreate != nil {
		mmOrderCreate.inspectFuncOrderCreate(ctx, order)
	}

	mm_params := LomsServerMockOrderCreateParams{ctx, order}

	// Record call args
	mmOrderCreate.OrderCreateMock.mutex.Lock()
	mmOrderCreate.OrderCreateMock.callArgs = append(mmOrderCreate.OrderCreateMock.callArgs, &mm_params)
	mmOrderCreate.OrderCreateMock.mutex.Unlock()

	for _, e := range mmOrderCreate.OrderCreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmOrderCreate.OrderCreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderCreate.OrderCreateMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderCreate.OrderCreateMock.defaultExpectation.params
		mm_want_ptrs := mmOrderCreate.OrderCreateMock.defaultExpectation.paramPtrs

		mm_got := LomsServerMockOrderCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderCreate.t.Errorf("LomsServerMock.OrderCreate got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmOrderCreate.t.Errorf("LomsServerMock.OrderCreate got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderCreate.t.Errorf("LomsServerMock.OrderCreate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderCreate.OrderCreateMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderCreate.t.Fatal("No results are set for the LomsServerMock.OrderCreate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmOrderCreate.funcOrderCreate != nil {
		return mmOrderCreate.funcOrderCreate(ctx, order)
	}
	mmOrderCreate.t.Fatalf("Unexpected call to LomsServerMock.OrderCreate. %v %v", ctx, order)
	return
}

// OrderCreateAfterCounter returns a count of finished LomsServerMock.OrderCreate invocations
func (mmOrderCreate *LomsServerMock) OrderCreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.afterOrderCreateCounter)
}

// OrderCreateBeforeCounter returns a count of LomsServerMock.OrderCreate invocations
func (mmOrderCreate *LomsServerMock) OrderCreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderCreate.beforeOrderCreateCounter)
}

// Calls returns a list of arguments used in each call to LomsServerMock.OrderCreate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderCreate *mLomsServerMockOrderCreate) Calls() []*LomsServerMockOrderCreateParams {
	mmOrderCreate.mutex.RLock()

	argCopy := make([]*LomsServerMockOrderCreateParams, len(mmOrderCreate.callArgs))
	copy(argCopy, mmOrderCreate.callArgs)

	mmOrderCreate.mutex.RUnlock()

	return argCopy
}

// MinimockOrderCreateDone returns true if the count of the OrderCreate invocations corresponds
// the number of defined expectations
func (m *LomsServerMock) MinimockOrderCreateDone() bool {
	if m.OrderCreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderCreateMock.invocationsDone()
}

// MinimockOrderCreateInspect logs each unmet expectation
func (m *LomsServerMock) MinimockOrderCreateInspect() {
	for _, e := range m.OrderCreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServerMock.OrderCreate with params: %#v", *e.params)
		}
	}

	afterOrderCreateCounter := mm_atomic.LoadUint64(&m.afterOrderCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderCreateMock.defaultExpectation != nil && afterOrderCreateCounter < 1 {
		if m.OrderCreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServerMock.OrderCreate")
		} else {
			m.t.Errorf("Expected call to LomsServerMock.OrderCreate with params: %#v", *m.OrderCreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderCreate != nil && afterOrderCreateCounter < 1 {
		m.t.Error("Expected call to LomsServerMock.OrderCreate")
	}

	if !m.OrderCreateMock.invocationsDone() && afterOrderCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServerMock.OrderCreate but found %d calls",
			mm_atomic.LoadUint64(&m.OrderCreateMock.expectedInvocations), afterOrderCreateCounter)
	}
}

type mLomsServerMockOrderInfo struct {
	optional           bool
	mock               *LomsServerMock
	defaultExpectation *LomsServerMockOrderInfoExpectation
	expectations       []*LomsServerMockOrderInfoExpectation

	callArgs []*LomsServerMockOrderInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServerMockOrderInfoExpectation specifies expectation struct of the lomsServer.OrderInfo
type LomsServerMockOrderInfoExpectation struct {
	mock      *LomsServerMock
	params    *LomsServerMockOrderInfoParams
	paramPtrs *LomsServerMockOrderInfoParamPtrs
	results   *LomsServerMockOrderInfoResults
	Counter   uint64
}

// LomsServerMockOrderInfoParams contains parameters of the lomsServer.OrderInfo
type LomsServerMockOrderInfoParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServerMockOrderInfoParamPtrs contains pointers to parameters of the lomsServer.OrderInfo
type LomsServerMockOrderInfoParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServerMockOrderInfoResults contains results of the lomsServer.OrderInfo
type LomsServerMockOrderInfoResults struct {
	o1  models.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderInfo *mLomsServerMockOrderInfo) Optional() *mLomsServerMockOrderInfo {
	mmOrderInfo.optional = true
	return mmOrderInfo
}

// Expect sets up expected params for lomsServer.OrderInfo
func (mmOrderInfo *mLomsServerMockOrderInfo) Expect(ctx context.Context, orderID int64) *mLomsServerMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServerMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.paramPtrs != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by ExpectParams functions")
	}

	mmOrderInfo.defaultExpectation.params = &LomsServerMockOrderInfoParams{ctx, orderID}
	for _, e := range mmOrderInfo.expectations {
		if minimock.Equal(e.params, mmOrderInfo.defaultExpectation.params) {
			mmOrderInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderInfo.defaultExpectation.params)
		}
	}

	return mmOrderInfo
}

// ExpectCtxParam1 sets up expected param ctx for lomsServer.OrderInfo
func (mmOrderInfo *mLomsServerMockOrderInfo) ExpectCtxParam1(ctx context.Context) *mLomsServerMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServerMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServerMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderInfo
}

// ExpectOrderIDParam2 sets up expected param orderID for lomsServer.OrderInfo
func (mmOrderInfo *mLomsServerMockOrderInfo) ExpectOrderIDParam2(orderID int64) *mLomsServerMockOrderInfo {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServerMockOrderInfoExpectation{}
	}

	if mmOrderInfo.defaultExpectation.params != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Expect")
	}

	if mmOrderInfo.defaultExpectation.paramPtrs == nil {
		mmOrderInfo.defaultExpectation.paramPtrs = &LomsServerMockOrderInfoParamPtrs{}
	}
	mmOrderInfo.defaultExpectation.paramPtrs.orderID = &orderID

	return mmOrderInfo
}

// Inspect accepts an inspector function that has same arguments as the lomsServer.OrderInfo
func (mmOrderInfo *mLomsServerMockOrderInfo) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServerMockOrderInfo {
	if mmOrderInfo.mock.inspectFuncOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("Inspect function is already set for LomsServerMock.OrderInfo")
	}

	mmOrderInfo.mock.inspectFuncOrderInfo = f

	return mmOrderInfo
}

// Return sets up results that will be returned by lomsServer.OrderInfo
func (mmOrderInfo *mLomsServerMockOrderInfo) Return(o1 models.Order, err error) *LomsServerMock {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Set")
	}

	if mmOrderInfo.defaultExpectation == nil {
		mmOrderInfo.defaultExpectation = &LomsServerMockOrderInfoExpectation{mock: mmOrderInfo.mock}
	}
	mmOrderInfo.defaultExpectation.results = &LomsServerMockOrderInfoResults{o1, err}
	return mmOrderInfo.mock
}

// Set uses given function f to mock the lomsServer.OrderInfo method
func (mmOrderInfo *mLomsServerMockOrderInfo) Set(f func(ctx context.Context, orderID int64) (o1 models.Order, err error)) *LomsServerMock {
	if mmOrderInfo.defaultExpectation != nil {
		mmOrderInfo.mock.t.Fatalf("Default expectation is already set for the lomsServer.OrderInfo method")
	}

	if len(mmOrderInfo.expectations) > 0 {
		mmOrderInfo.mock.t.Fatalf("Some expectations are already set for the lomsServer.OrderInfo method")
	}

	mmOrderInfo.mock.funcOrderInfo = f
	return mmOrderInfo.mock
}

// When sets expectation for the lomsServer.OrderInfo which will trigger the result defined by the following
// Then helper
func (mmOrderInfo *mLomsServerMockOrderInfo) When(ctx context.Context, orderID int64) *LomsServerMockOrderInfoExpectation {
	if mmOrderInfo.mock.funcOrderInfo != nil {
		mmOrderInfo.mock.t.Fatalf("LomsServerMock.OrderInfo mock is already set by Set")
	}

	expectation := &LomsServerMockOrderInfoExpectation{
		mock:   mmOrderInfo.mock,
		params: &LomsServerMockOrderInfoParams{ctx, orderID},
	}
	mmOrderInfo.expectations = append(mmOrderInfo.expectations, expectation)
	return expectation
}

// Then sets up lomsServer.OrderInfo return parameters for the expectation previously defined by the When method
func (e *LomsServerMockOrderInfoExpectation) Then(o1 models.Order, err error) *LomsServerMock {
	e.results = &LomsServerMockOrderInfoResults{o1, err}
	return e.mock
}

// Times sets number of times lomsServer.OrderInfo should be invoked
func (mmOrderInfo *mLomsServerMockOrderInfo) Times(n uint64) *mLomsServerMockOrderInfo {
	if n == 0 {
		mmOrderInfo.mock.t.Fatalf("Times of LomsServerMock.OrderInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderInfo.expectedInvocations, n)
	return mmOrderInfo
}

func (mmOrderInfo *mLomsServerMockOrderInfo) invocationsDone() bool {
	if len(mmOrderInfo.expectations) == 0 && mmOrderInfo.defaultExpectation == nil && mmOrderInfo.mock.funcOrderInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderInfo.mock.afterOrderInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderInfo implements lomsServer
func (mmOrderInfo *LomsServerMock) OrderInfo(ctx context.Context, orderID int64) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmOrderInfo.beforeOrderInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderInfo.afterOrderInfoCounter, 1)

	if mmOrderInfo.inspectFuncOrderInfo != nil {
		mmOrderInfo.inspectFuncOrderInfo(ctx, orderID)
	}

	mm_params := LomsServerMockOrderInfoParams{ctx, orderID}

	// Record call args
	mmOrderInfo.OrderInfoMock.mutex.Lock()
	mmOrderInfo.OrderInfoMock.callArgs = append(mmOrderInfo.OrderInfoMock.callArgs, &mm_params)
	mmOrderInfo.OrderInfoMock.mutex.Unlock()

	for _, e := range mmOrderInfo.OrderInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmOrderInfo.OrderInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderInfo.OrderInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderInfo.OrderInfoMock.defaultExpectation.params
		mm_want_ptrs := mmOrderInfo.OrderInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServerMockOrderInfoParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderInfo.t.Errorf("LomsServerMock.OrderInfo got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderInfo.t.Errorf("LomsServerMock.OrderInfo got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderInfo.t.Errorf("LomsServerMock.OrderInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderInfo.OrderInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderInfo.t.Fatal("No results are set for the LomsServerMock.OrderInfo")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmOrderInfo.funcOrderInfo != nil {
		return mmOrderInfo.funcOrderInfo(ctx, orderID)
	}
	mmOrderInfo.t.Fatalf("Unexpected call to LomsServerMock.OrderInfo. %v %v", ctx, orderID)
	return
}

// OrderInfoAfterCounter returns a count of finished LomsServerMock.OrderInfo invocations
func (mmOrderInfo *LomsServerMock) OrderInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.afterOrderInfoCounter)
}

// OrderInfoBeforeCounter returns a count of LomsServerMock.OrderInfo invocations
func (mmOrderInfo *LomsServerMock) OrderInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderInfo.beforeOrderInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServerMock.OrderInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderInfo *mLomsServerMockOrderInfo) Calls() []*LomsServerMockOrderInfoParams {
	mmOrderInfo.mutex.RLock()

	argCopy := make([]*LomsServerMockOrderInfoParams, len(mmOrderInfo.callArgs))
	copy(argCopy, mmOrderInfo.callArgs)

	mmOrderInfo.mutex.RUnlock()

	return argCopy
}

// MinimockOrderInfoDone returns true if the count of the OrderInfo invocations corresponds
// the number of defined expectations
func (m *LomsServerMock) MinimockOrderInfoDone() bool {
	if m.OrderInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderInfoMock.invocationsDone()
}

// MinimockOrderInfoInspect logs each unmet expectation
func (m *LomsServerMock) MinimockOrderInfoInspect() {
	for _, e := range m.OrderInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServerMock.OrderInfo with params: %#v", *e.params)
		}
	}

	afterOrderInfoCounter := mm_atomic.LoadUint64(&m.afterOrderInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderInfoMock.defaultExpectation != nil && afterOrderInfoCounter < 1 {
		if m.OrderInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServerMock.OrderInfo")
		} else {
			m.t.Errorf("Expected call to LomsServerMock.OrderInfo with params: %#v", *m.OrderInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderInfo != nil && afterOrderInfoCounter < 1 {
		m.t.Error("Expected call to LomsServerMock.OrderInfo")
	}

	if !m.OrderInfoMock.invocationsDone() && afterOrderInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServerMock.OrderInfo but found %d calls",
			mm_atomic.LoadUint64(&m.OrderInfoMock.expectedInvocations), afterOrderInfoCounter)
	}
}

type mLomsServerMockOrderPay struct {
	optional           bool
	mock               *LomsServerMock
	defaultExpectation *LomsServerMockOrderPayExpectation
	expectations       []*LomsServerMockOrderPayExpectation

	callArgs []*LomsServerMockOrderPayParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServerMockOrderPayExpectation specifies expectation struct of the lomsServer.OrderPay
type LomsServerMockOrderPayExpectation struct {
	mock      *LomsServerMock
	params    *LomsServerMockOrderPayParams
	paramPtrs *LomsServerMockOrderPayParamPtrs
	results   *LomsServerMockOrderPayResults
	Counter   uint64
}

// LomsServerMockOrderPayParams contains parameters of the lomsServer.OrderPay
type LomsServerMockOrderPayParams struct {
	ctx     context.Context
	orderID int64
}

// LomsServerMockOrderPayParamPtrs contains pointers to parameters of the lomsServer.OrderPay
type LomsServerMockOrderPayParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// LomsServerMockOrderPayResults contains results of the lomsServer.OrderPay
type LomsServerMockOrderPayResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrderPay *mLomsServerMockOrderPay) Optional() *mLomsServerMockOrderPay {
	mmOrderPay.optional = true
	return mmOrderPay
}

// Expect sets up expected params for lomsServer.OrderPay
func (mmOrderPay *mLomsServerMockOrderPay) Expect(ctx context.Context, orderID int64) *mLomsServerMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServerMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.paramPtrs != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by ExpectParams functions")
	}

	mmOrderPay.defaultExpectation.params = &LomsServerMockOrderPayParams{ctx, orderID}
	for _, e := range mmOrderPay.expectations {
		if minimock.Equal(e.params, mmOrderPay.defaultExpectation.params) {
			mmOrderPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPay.defaultExpectation.params)
		}
	}

	return mmOrderPay
}

// ExpectCtxParam1 sets up expected param ctx for lomsServer.OrderPay
func (mmOrderPay *mLomsServerMockOrderPay) ExpectCtxParam1(ctx context.Context) *mLomsServerMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServerMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServerMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.ctx = &ctx

	return mmOrderPay
}

// ExpectOrderIDParam2 sets up expected param orderID for lomsServer.OrderPay
func (mmOrderPay *mLomsServerMockOrderPay) ExpectOrderIDParam2(orderID int64) *mLomsServerMockOrderPay {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServerMockOrderPayExpectation{}
	}

	if mmOrderPay.defaultExpectation.params != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Expect")
	}

	if mmOrderPay.defaultExpectation.paramPtrs == nil {
		mmOrderPay.defaultExpectation.paramPtrs = &LomsServerMockOrderPayParamPtrs{}
	}
	mmOrderPay.defaultExpectation.paramPtrs.orderID = &orderID

	return mmOrderPay
}

// Inspect accepts an inspector function that has same arguments as the lomsServer.OrderPay
func (mmOrderPay *mLomsServerMockOrderPay) Inspect(f func(ctx context.Context, orderID int64)) *mLomsServerMockOrderPay {
	if mmOrderPay.mock.inspectFuncOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("Inspect function is already set for LomsServerMock.OrderPay")
	}

	mmOrderPay.mock.inspectFuncOrderPay = f

	return mmOrderPay
}

// Return sets up results that will be returned by lomsServer.OrderPay
func (mmOrderPay *mLomsServerMockOrderPay) Return(err error) *LomsServerMock {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Set")
	}

	if mmOrderPay.defaultExpectation == nil {
		mmOrderPay.defaultExpectation = &LomsServerMockOrderPayExpectation{mock: mmOrderPay.mock}
	}
	mmOrderPay.defaultExpectation.results = &LomsServerMockOrderPayResults{err}
	return mmOrderPay.mock
}

// Set uses given function f to mock the lomsServer.OrderPay method
func (mmOrderPay *mLomsServerMockOrderPay) Set(f func(ctx context.Context, orderID int64) (err error)) *LomsServerMock {
	if mmOrderPay.defaultExpectation != nil {
		mmOrderPay.mock.t.Fatalf("Default expectation is already set for the lomsServer.OrderPay method")
	}

	if len(mmOrderPay.expectations) > 0 {
		mmOrderPay.mock.t.Fatalf("Some expectations are already set for the lomsServer.OrderPay method")
	}

	mmOrderPay.mock.funcOrderPay = f
	return mmOrderPay.mock
}

// When sets expectation for the lomsServer.OrderPay which will trigger the result defined by the following
// Then helper
func (mmOrderPay *mLomsServerMockOrderPay) When(ctx context.Context, orderID int64) *LomsServerMockOrderPayExpectation {
	if mmOrderPay.mock.funcOrderPay != nil {
		mmOrderPay.mock.t.Fatalf("LomsServerMock.OrderPay mock is already set by Set")
	}

	expectation := &LomsServerMockOrderPayExpectation{
		mock:   mmOrderPay.mock,
		params: &LomsServerMockOrderPayParams{ctx, orderID},
	}
	mmOrderPay.expectations = append(mmOrderPay.expectations, expectation)
	return expectation
}

// Then sets up lomsServer.OrderPay return parameters for the expectation previously defined by the When method
func (e *LomsServerMockOrderPayExpectation) Then(err error) *LomsServerMock {
	e.results = &LomsServerMockOrderPayResults{err}
	return e.mock
}

// Times sets number of times lomsServer.OrderPay should be invoked
func (mmOrderPay *mLomsServerMockOrderPay) Times(n uint64) *mLomsServerMockOrderPay {
	if n == 0 {
		mmOrderPay.mock.t.Fatalf("Times of LomsServerMock.OrderPay mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrderPay.expectedInvocations, n)
	return mmOrderPay
}

func (mmOrderPay *mLomsServerMockOrderPay) invocationsDone() bool {
	if len(mmOrderPay.expectations) == 0 && mmOrderPay.defaultExpectation == nil && mmOrderPay.mock.funcOrderPay == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrderPay.mock.afterOrderPayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrderPay.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OrderPay implements lomsServer
func (mmOrderPay *LomsServerMock) OrderPay(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmOrderPay.beforeOrderPayCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPay.afterOrderPayCounter, 1)

	if mmOrderPay.inspectFuncOrderPay != nil {
		mmOrderPay.inspectFuncOrderPay(ctx, orderID)
	}

	mm_params := LomsServerMockOrderPayParams{ctx, orderID}

	// Record call args
	mmOrderPay.OrderPayMock.mutex.Lock()
	mmOrderPay.OrderPayMock.callArgs = append(mmOrderPay.OrderPayMock.callArgs, &mm_params)
	mmOrderPay.OrderPayMock.mutex.Unlock()

	for _, e := range mmOrderPay.OrderPayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPay.OrderPayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPay.OrderPayMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPay.OrderPayMock.defaultExpectation.params
		mm_want_ptrs := mmOrderPay.OrderPayMock.defaultExpectation.paramPtrs

		mm_got := LomsServerMockOrderPayParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrderPay.t.Errorf("LomsServerMock.OrderPay got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmOrderPay.t.Errorf("LomsServerMock.OrderPay got unexpected parameter orderID, want: %#v, got: %#v%s\n", *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPay.t.Errorf("LomsServerMock.OrderPay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPay.OrderPayMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPay.t.Fatal("No results are set for the LomsServerMock.OrderPay")
		}
		return (*mm_results).err
	}
	if mmOrderPay.funcOrderPay != nil {
		return mmOrderPay.funcOrderPay(ctx, orderID)
	}
	mmOrderPay.t.Fatalf("Unexpected call to LomsServerMock.OrderPay. %v %v", ctx, orderID)
	return
}

// OrderPayAfterCounter returns a count of finished LomsServerMock.OrderPay invocations
func (mmOrderPay *LomsServerMock) OrderPayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.afterOrderPayCounter)
}

// OrderPayBeforeCounter returns a count of LomsServerMock.OrderPay invocations
func (mmOrderPay *LomsServerMock) OrderPayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPay.beforeOrderPayCounter)
}

// Calls returns a list of arguments used in each call to LomsServerMock.OrderPay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPay *mLomsServerMockOrderPay) Calls() []*LomsServerMockOrderPayParams {
	mmOrderPay.mutex.RLock()

	argCopy := make([]*LomsServerMockOrderPayParams, len(mmOrderPay.callArgs))
	copy(argCopy, mmOrderPay.callArgs)

	mmOrderPay.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayDone returns true if the count of the OrderPay invocations corresponds
// the number of defined expectations
func (m *LomsServerMock) MinimockOrderPayDone() bool {
	if m.OrderPayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderPayMock.invocationsDone()
}

// MinimockOrderPayInspect logs each unmet expectation
func (m *LomsServerMock) MinimockOrderPayInspect() {
	for _, e := range m.OrderPayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServerMock.OrderPay with params: %#v", *e.params)
		}
	}

	afterOrderPayCounter := mm_atomic.LoadUint64(&m.afterOrderPayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayMock.defaultExpectation != nil && afterOrderPayCounter < 1 {
		if m.OrderPayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServerMock.OrderPay")
		} else {
			m.t.Errorf("Expected call to LomsServerMock.OrderPay with params: %#v", *m.OrderPayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPay != nil && afterOrderPayCounter < 1 {
		m.t.Error("Expected call to LomsServerMock.OrderPay")
	}

	if !m.OrderPayMock.invocationsDone() && afterOrderPayCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServerMock.OrderPay but found %d calls",
			mm_atomic.LoadUint64(&m.OrderPayMock.expectedInvocations), afterOrderPayCounter)
	}
}

type mLomsServerMockStocksInfo struct {
	optional           bool
	mock               *LomsServerMock
	defaultExpectation *LomsServerMockStocksInfoExpectation
	expectations       []*LomsServerMockStocksInfoExpectation

	callArgs []*LomsServerMockStocksInfoParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// LomsServerMockStocksInfoExpectation specifies expectation struct of the lomsServer.StocksInfo
type LomsServerMockStocksInfoExpectation struct {
	mock      *LomsServerMock
	params    *LomsServerMockStocksInfoParams
	paramPtrs *LomsServerMockStocksInfoParamPtrs
	results   *LomsServerMockStocksInfoResults
	Counter   uint64
}

// LomsServerMockStocksInfoParams contains parameters of the lomsServer.StocksInfo
type LomsServerMockStocksInfoParams struct {
	ctx   context.Context
	skuID uint32
}

// LomsServerMockStocksInfoParamPtrs contains pointers to parameters of the lomsServer.StocksInfo
type LomsServerMockStocksInfoParamPtrs struct {
	ctx   *context.Context
	skuID *uint32
}

// LomsServerMockStocksInfoResults contains results of the lomsServer.StocksInfo
type LomsServerMockStocksInfoResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option by default unless you really need it, as it helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStocksInfo *mLomsServerMockStocksInfo) Optional() *mLomsServerMockStocksInfo {
	mmStocksInfo.optional = true
	return mmStocksInfo
}

// Expect sets up expected params for lomsServer.StocksInfo
func (mmStocksInfo *mLomsServerMockStocksInfo) Expect(ctx context.Context, skuID uint32) *mLomsServerMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServerMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.paramPtrs != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by ExpectParams functions")
	}

	mmStocksInfo.defaultExpectation.params = &LomsServerMockStocksInfoParams{ctx, skuID}
	for _, e := range mmStocksInfo.expectations {
		if minimock.Equal(e.params, mmStocksInfo.defaultExpectation.params) {
			mmStocksInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocksInfo.defaultExpectation.params)
		}
	}

	return mmStocksInfo
}

// ExpectCtxParam1 sets up expected param ctx for lomsServer.StocksInfo
func (mmStocksInfo *mLomsServerMockStocksInfo) ExpectCtxParam1(ctx context.Context) *mLomsServerMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServerMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServerMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.ctx = &ctx

	return mmStocksInfo
}

// ExpectSkuIDParam2 sets up expected param skuID for lomsServer.StocksInfo
func (mmStocksInfo *mLomsServerMockStocksInfo) ExpectSkuIDParam2(skuID uint32) *mLomsServerMockStocksInfo {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServerMockStocksInfoExpectation{}
	}

	if mmStocksInfo.defaultExpectation.params != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Expect")
	}

	if mmStocksInfo.defaultExpectation.paramPtrs == nil {
		mmStocksInfo.defaultExpectation.paramPtrs = &LomsServerMockStocksInfoParamPtrs{}
	}
	mmStocksInfo.defaultExpectation.paramPtrs.skuID = &skuID

	return mmStocksInfo
}

// Inspect accepts an inspector function that has same arguments as the lomsServer.StocksInfo
func (mmStocksInfo *mLomsServerMockStocksInfo) Inspect(f func(ctx context.Context, skuID uint32)) *mLomsServerMockStocksInfo {
	if mmStocksInfo.mock.inspectFuncStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("Inspect function is already set for LomsServerMock.StocksInfo")
	}

	mmStocksInfo.mock.inspectFuncStocksInfo = f

	return mmStocksInfo
}

// Return sets up results that will be returned by lomsServer.StocksInfo
func (mmStocksInfo *mLomsServerMockStocksInfo) Return(i1 int64, err error) *LomsServerMock {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Set")
	}

	if mmStocksInfo.defaultExpectation == nil {
		mmStocksInfo.defaultExpectation = &LomsServerMockStocksInfoExpectation{mock: mmStocksInfo.mock}
	}
	mmStocksInfo.defaultExpectation.results = &LomsServerMockStocksInfoResults{i1, err}
	return mmStocksInfo.mock
}

// Set uses given function f to mock the lomsServer.StocksInfo method
func (mmStocksInfo *mLomsServerMockStocksInfo) Set(f func(ctx context.Context, skuID uint32) (i1 int64, err error)) *LomsServerMock {
	if mmStocksInfo.defaultExpectation != nil {
		mmStocksInfo.mock.t.Fatalf("Default expectation is already set for the lomsServer.StocksInfo method")
	}

	if len(mmStocksInfo.expectations) > 0 {
		mmStocksInfo.mock.t.Fatalf("Some expectations are already set for the lomsServer.StocksInfo method")
	}

	mmStocksInfo.mock.funcStocksInfo = f
	return mmStocksInfo.mock
}

// When sets expectation for the lomsServer.StocksInfo which will trigger the result defined by the following
// Then helper
func (mmStocksInfo *mLomsServerMockStocksInfo) When(ctx context.Context, skuID uint32) *LomsServerMockStocksInfoExpectation {
	if mmStocksInfo.mock.funcStocksInfo != nil {
		mmStocksInfo.mock.t.Fatalf("LomsServerMock.StocksInfo mock is already set by Set")
	}

	expectation := &LomsServerMockStocksInfoExpectation{
		mock:   mmStocksInfo.mock,
		params: &LomsServerMockStocksInfoParams{ctx, skuID},
	}
	mmStocksInfo.expectations = append(mmStocksInfo.expectations, expectation)
	return expectation
}

// Then sets up lomsServer.StocksInfo return parameters for the expectation previously defined by the When method
func (e *LomsServerMockStocksInfoExpectation) Then(i1 int64, err error) *LomsServerMock {
	e.results = &LomsServerMockStocksInfoResults{i1, err}
	return e.mock
}

// Times sets number of times lomsServer.StocksInfo should be invoked
func (mmStocksInfo *mLomsServerMockStocksInfo) Times(n uint64) *mLomsServerMockStocksInfo {
	if n == 0 {
		mmStocksInfo.mock.t.Fatalf("Times of LomsServerMock.StocksInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStocksInfo.expectedInvocations, n)
	return mmStocksInfo
}

func (mmStocksInfo *mLomsServerMockStocksInfo) invocationsDone() bool {
	if len(mmStocksInfo.expectations) == 0 && mmStocksInfo.defaultExpectation == nil && mmStocksInfo.mock.funcStocksInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStocksInfo.mock.afterStocksInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStocksInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StocksInfo implements lomsServer
func (mmStocksInfo *LomsServerMock) StocksInfo(ctx context.Context, skuID uint32) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmStocksInfo.beforeStocksInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmStocksInfo.afterStocksInfoCounter, 1)

	if mmStocksInfo.inspectFuncStocksInfo != nil {
		mmStocksInfo.inspectFuncStocksInfo(ctx, skuID)
	}

	mm_params := LomsServerMockStocksInfoParams{ctx, skuID}

	// Record call args
	mmStocksInfo.StocksInfoMock.mutex.Lock()
	mmStocksInfo.StocksInfoMock.callArgs = append(mmStocksInfo.StocksInfoMock.callArgs, &mm_params)
	mmStocksInfo.StocksInfoMock.mutex.Unlock()

	for _, e := range mmStocksInfo.StocksInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmStocksInfo.StocksInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocksInfo.StocksInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmStocksInfo.StocksInfoMock.defaultExpectation.params
		mm_want_ptrs := mmStocksInfo.StocksInfoMock.defaultExpectation.paramPtrs

		mm_got := LomsServerMockStocksInfoParams{ctx, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStocksInfo.t.Errorf("LomsServerMock.StocksInfo got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmStocksInfo.t.Errorf("LomsServerMock.StocksInfo got unexpected parameter skuID, want: %#v, got: %#v%s\n", *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocksInfo.t.Errorf("LomsServerMock.StocksInfo got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocksInfo.StocksInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmStocksInfo.t.Fatal("No results are set for the LomsServerMock.StocksInfo")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmStocksInfo.funcStocksInfo != nil {
		return mmStocksInfo.funcStocksInfo(ctx, skuID)
	}
	mmStocksInfo.t.Fatalf("Unexpected call to LomsServerMock.StocksInfo. %v %v", ctx, skuID)
	return
}

// StocksInfoAfterCounter returns a count of finished LomsServerMock.StocksInfo invocations
func (mmStocksInfo *LomsServerMock) StocksInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.afterStocksInfoCounter)
}

// StocksInfoBeforeCounter returns a count of LomsServerMock.StocksInfo invocations
func (mmStocksInfo *LomsServerMock) StocksInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocksInfo.beforeStocksInfoCounter)
}

// Calls returns a list of arguments used in each call to LomsServerMock.StocksInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocksInfo *mLomsServerMockStocksInfo) Calls() []*LomsServerMockStocksInfoParams {
	mmStocksInfo.mutex.RLock()

	argCopy := make([]*LomsServerMockStocksInfoParams, len(mmStocksInfo.callArgs))
	copy(argCopy, mmStocksInfo.callArgs)

	mmStocksInfo.mutex.RUnlock()

	return argCopy
}

// MinimockStocksInfoDone returns true if the count of the StocksInfo invocations corresponds
// the number of defined expectations
func (m *LomsServerMock) MinimockStocksInfoDone() bool {
	if m.StocksInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StocksInfoMock.invocationsDone()
}

// MinimockStocksInfoInspect logs each unmet expectation
func (m *LomsServerMock) MinimockStocksInfoInspect() {
	for _, e := range m.StocksInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsServerMock.StocksInfo with params: %#v", *e.params)
		}
	}

	afterStocksInfoCounter := mm_atomic.LoadUint64(&m.afterStocksInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StocksInfoMock.defaultExpectation != nil && afterStocksInfoCounter < 1 {
		if m.StocksInfoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LomsServerMock.StocksInfo")
		} else {
			m.t.Errorf("Expected call to LomsServerMock.StocksInfo with params: %#v", *m.StocksInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocksInfo != nil && afterStocksInfoCounter < 1 {
		m.t.Error("Expected call to LomsServerMock.StocksInfo")
	}

	if !m.StocksInfoMock.invocationsDone() && afterStocksInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsServerMock.StocksInfo but found %d calls",
			mm_atomic.LoadUint64(&m.StocksInfoMock.expectedInvocations), afterStocksInfoCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsServerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOrderCancelInspect()

			m.MinimockOrderCreateInspect()

			m.MinimockOrderInfoInspect()

			m.MinimockOrderPayInspect()

			m.MinimockStocksInfoInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOrderCancelDone() &&
		m.MinimockOrderCreateDone() &&
		m.MinimockOrderInfoDone() &&
		m.MinimockOrderPayDone() &&
		m.MinimockStocksInfoDone()
}
