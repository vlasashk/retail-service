
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ordersmem: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">route256/loms/internal/loms/adapters/ordersmem/orders.go (0.0%)</option>
				
				<option value="file1">route256/loms/internal/loms/adapters/pgorders/dto.go (83.3%)</option>
				
				<option value="file2">route256/loms/internal/loms/adapters/pgorders/pgordersqry/copyfrom.go (90.0%)</option>
				
				<option value="file3">route256/loms/internal/loms/adapters/pgorders/pgordersqry/db.go (50.0%)</option>
				
				<option value="file4">route256/loms/internal/loms/adapters/pgorders/pgordersqry/models.go (23.1%)</option>
				
				<option value="file5">route256/loms/internal/loms/adapters/pgorders/pgordersqry/queries.sql.go (85.7%)</option>
				
				<option value="file6">route256/loms/internal/loms/adapters/pgorders/repo.go (75.4%)</option>
				
				<option value="file7">route256/loms/internal/loms/adapters/pgstocks/pgstocksqry/db.go (50.0%)</option>
				
				<option value="file8">route256/loms/internal/loms/adapters/pgstocks/pgstocksqry/models.go (0.0%)</option>
				
				<option value="file9">route256/loms/internal/loms/adapters/pgstocks/pgstocksqry/queries.sql.go (100.0%)</option>
				
				<option value="file10">route256/loms/internal/loms/adapters/pgstocks/repo.go (71.4%)</option>
				
				<option value="file11">route256/loms/internal/loms/adapters/stocksmem/stocks.go (0.0%)</option>
				
				<option value="file12">route256/loms/internal/loms/ports/ggrpc/impl/dto.go (82.4%)</option>
				
				<option value="file13">route256/loms/internal/loms/ports/ggrpc/impl/errors.go (100.0%)</option>
				
				<option value="file14">route256/loms/internal/loms/ports/ggrpc/impl/impl.go (100.0%)</option>
				
				<option value="file15">route256/loms/internal/loms/ports/ggrpc/interceptors/logger.go (77.8%)</option>
				
				<option value="file16">route256/loms/internal/loms/ports/ggrpc/interceptors/recover.go (66.7%)</option>
				
				<option value="file17">route256/loms/internal/loms/ports/ggrpc/interceptors/validate.go (75.0%)</option>
				
				<option value="file18">route256/loms/internal/loms/ports/ggrpc/server.go (100.0%)</option>
				
				<option value="file19">route256/loms/internal/loms/ports/httpgate/errors.go (0.0%)</option>
				
				<option value="file20">route256/loms/internal/loms/ports/httpgate/server.go (76.9%)</option>
				
				<option value="file21">route256/loms/internal/loms/resources/resources.go (69.2%)</option>
				
				<option value="file22">route256/loms/internal/loms/service.go (82.4%)</option>
				
				<option value="file23">route256/loms/internal/loms/usecase/usecase.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ordersmem

import (
        "context"
        "math/rand/v2"
        "sync"
        "time"

        "route256/loms/internal/loms/models"
)

type userOrder struct {
        models.Order
        createdAt time.Time
}

type Orders struct {
        mu     sync.RWMutex
        orders map[int64]userOrder
}

func New() *Orders <span class="cov0" title="0">{
        return &amp;Orders{
                mu:     sync.RWMutex{},
                orders: make(map[int64]userOrder),
        }
}</span>

func (o *Orders) Create(_ context.Context, order models.Order) (int64, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        orderID := rand.Int64()

        for _, exist := o.orders[orderID]; exist; </span><span class="cov0" title="0">{
                orderID = rand.Int64()
        }</span>

        <span class="cov0" title="0">orderToCreat := userOrder{
                Order:     order,
                createdAt: time.Now(),
        }
        orderToCreat.Status = models.NewStatus

        o.orders[orderID] = orderToCreat

        return orderID, nil</span>
}

func (o *Orders) SetStatus(_ context.Context, orderID int64, status models.OrderStatus) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        order, ok := o.orders[orderID]
        if !ok </span><span class="cov0" title="0">{
                return models.ErrOrderNotFound
        }</span>

        <span class="cov0" title="0">order.Status = status
        o.orders[orderID] = order

        return nil</span>
}

func (o *Orders) GetByOrderID(_ context.Context, orderID int64) (models.Order, error) <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()

        order, ok := o.orders[orderID]
        if !ok </span><span class="cov0" title="0">{
                return models.Order{}, models.ErrOrderNotFound
        }</span>

        <span class="cov0" title="0">return order.Order, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package pgorders

import (
        "time"

        "route256/loms/internal/loms/adapters/pgorders/pgordersqry"
        "route256/loms/internal/loms/models"

        "github.com/jackc/pgx/v5/pgtype"
)

func statusToDTO(status models.OrderStatus) pgordersqry.OrdersOrderStatus <span class="cov8" title="11">{
        switch status </span>{
        case models.NewStatus:<span class="cov5" title="4">
                return pgordersqry.OrdersOrderStatusNew</span>
        case models.AwaitingPaymentStatus:<span class="cov3" title="2">
                return pgordersqry.OrdersOrderStatusAwaitingPayment</span>
        case models.PayedStatus:<span class="cov1" title="1">
                return pgordersqry.OrdersOrderStatusPayed</span>
        case models.CancelledStatus:<span class="cov3" title="2">
                return pgordersqry.OrdersOrderStatusCancelled</span>
        case models.FailedStatus:<span class="cov3" title="2">
                return pgordersqry.OrdersOrderStatusFailed</span>
        default:<span class="cov0" title="0">
                return pgordersqry.OrdersOrderStatusUnknown</span>
        }
}

func statusToDomain(status pgordersqry.OrdersOrderStatus) models.OrderStatus <span class="cov8" title="9">{
        switch status </span>{
        case pgordersqry.OrdersOrderStatusNew:<span class="cov0" title="0">
                return models.NewStatus</span>
        case pgordersqry.OrdersOrderStatusAwaitingPayment:<span class="cov6" title="5">
                return models.AwaitingPaymentStatus</span>
        case pgordersqry.OrdersOrderStatusPayed:<span class="cov3" title="2">
                return models.PayedStatus</span>
        case pgordersqry.OrdersOrderStatusCancelled:<span class="cov3" title="2">
                return models.CancelledStatus</span>
        case pgordersqry.OrdersOrderStatusFailed:<span class="cov0" title="0">
                return models.FailedStatus</span>
        default:<span class="cov0" title="0">
                return models.UnknownStatus</span>
        }
}

func orderToDTO(order models.Order) pgordersqry.OrdersOrder <span class="cov5" title="4">{
        return pgordersqry.OrdersOrder{
                UserID: order.UserID,
                Status: statusToDTO(order.Status),
                CreatedAt: pgtype.Timestamp{
                        Time:  time.Now(),
                        Valid: true,
                },
                UpdatedAt: pgtype.Timestamp{
                        Time:  time.Now(),
                        Valid: true,
                },
        }
}</span>

func orderToDomain(order pgordersqry.GetOrderByIdRow, items []pgordersqry.GetOrderItemsRow) models.Order <span class="cov8" title="9">{
        return models.Order{
                UserID: order.UserID,
                Items:  itemsToDomain(items),
                Status: statusToDomain(order.Status),
        }
}</span>

func itemsToDTO(orderID int64, items []models.Item) []pgordersqry.InsertOrderItemsParams <span class="cov5" title="4">{
        itemsDTO := make([]pgordersqry.InsertOrderItemsParams, 0, len(items))

        for _, item := range items </span><span class="cov6" title="5">{
                itemsDTO = append(itemsDTO, pgordersqry.InsertOrderItemsParams{
                        SkuID:   int64(item.SKUid),
                        OrderID: orderID,
                        Count:   int64(item.Count),
                        CreatedAt: pgtype.Timestamp{
                                Time:  time.Now(),
                                Valid: true,
                        },
                        UpdatedAt: pgtype.Timestamp{
                                Time:  time.Now(),
                                Valid: true,
                        },
                })
        }</span>

        <span class="cov5" title="4">return itemsDTO</span>
}

func itemsToDomain(itemsDTO []pgordersqry.GetOrderItemsRow) []models.Item <span class="cov8" title="9">{
        items := make([]models.Item, 0, len(itemsDTO))

        for _, item := range itemsDTO </span><span class="cov10" title="15">{
                items = append(items, models.Item{
                        SKUid: uint32(item.SkuID),
                        Count: uint32(item.Count),
                })
        }</span>

        <span class="cov8" title="9">return items</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: copyfrom.go

package pgordersqry

import (
        "context"
)

// iteratorForInsertOrderItems implements pgx.CopyFromSource.
type iteratorForInsertOrderItems struct {
        rows                 []InsertOrderItemsParams
        skippedFirstNextCall bool
}

func (r *iteratorForInsertOrderItems) Next() bool <span class="cov10" title="9">{
        if len(r.rows) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov10" title="9">if !r.skippedFirstNextCall </span><span class="cov6" title="4">{
                r.skippedFirstNextCall = true
                return true
        }</span>
        <span class="cov7" title="5">r.rows = r.rows[1:]
        return len(r.rows) &gt; 0</span>
}

func (r iteratorForInsertOrderItems) Values() ([]interface{}, error) <span class="cov7" title="5">{
        return []interface{}{
                r.rows[0].SkuID,
                r.rows[0].OrderID,
                r.rows[0].Count,
                r.rows[0].CreatedAt,
                r.rows[0].UpdatedAt,
        }, nil
}</span>

func (r iteratorForInsertOrderItems) Err() error <span class="cov6" title="4">{
        return nil
}</span>

func (q *Queries) InsertOrderItems(ctx context.Context, arg []InsertOrderItemsParams) (int64, error) <span class="cov6" title="4">{
        return q.db.CopyFrom(ctx, []string{"orders", "order_items"}, []string{"sku_id", "order_id", "count", "created_at", "updated_at"}, &amp;iteratorForInsertOrderItems{rows: arg})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package pgordersqry

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
        CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
}

func New(db DBTX) *Queries <span class="cov10" title="16">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package pgordersqry

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type OrdersOrderStatus string

const (
        OrdersOrderStatusUnknown         OrdersOrderStatus = "Unknown"
        OrdersOrderStatusNew             OrdersOrderStatus = "New"
        OrdersOrderStatusAwaitingPayment OrdersOrderStatus = "AwaitingPayment"
        OrdersOrderStatusPayed           OrdersOrderStatus = "Payed"
        OrdersOrderStatusCancelled       OrdersOrderStatus = "Cancelled"
        OrdersOrderStatusFailed          OrdersOrderStatus = "Failed"
)

func (e *OrdersOrderStatus) Scan(src interface{}) error <span class="cov10" title="9">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = OrdersOrderStatus(s)</span>
        case string:<span class="cov10" title="9">
                *e = OrdersOrderStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for OrdersOrderStatus: %T", src)</span>
        }
        <span class="cov10" title="9">return nil</span>
}

type NullOrdersOrderStatus struct {
        OrdersOrderStatus OrdersOrderStatus
        Valid             bool // Valid is true if OrdersOrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrdersOrderStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.OrdersOrderStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.OrdersOrderStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullOrdersOrderStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.OrdersOrderStatus), nil</span>
}

type OrdersOrder struct {
        ID        int64
        UserID    int64
        Status    OrdersOrderStatus
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}

type OrdersOrderItem struct {
        SkuID     int64
        OrderID   int64
        Count     int64
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}

type StocksStock struct {
        ID        int64
        Available int64
        Reserved  int64
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package pgordersqry

import (
        "context"

        "github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders.orders (user_id, status, created_at, updated_at)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateOrderParams struct {
        UserID    int64
        Status    OrdersOrderStatus
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int64, error) <span class="cov5" title="4">{
        row := q.db.QueryRow(ctx, createOrder,
                arg.UserID,
                arg.Status,
                arg.CreatedAt,
                arg.UpdatedAt,
        )
        var id int64
        err := row.Scan(&amp;id)
        return id, err
}</span>

const getOrderById = `-- name: GetOrderById :one
SELECT id, user_id, status
FROM orders.orders
WHERE id = $1
`

type GetOrderByIdRow struct {
        ID     int64
        UserID int64
        Status OrdersOrderStatus
}

func (q *Queries) GetOrderById(ctx context.Context, id int64) (GetOrderByIdRow, error) <span class="cov9" title="12">{
        row := q.db.QueryRow(ctx, getOrderById, id)
        var i GetOrderByIdRow
        err := row.Scan(&amp;i.ID, &amp;i.UserID, &amp;i.Status)
        return i, err
}</span>

const getOrderItems = `-- name: GetOrderItems :many
SELECT sku_id, order_id, count
FROM orders.order_items
WHERE order_id = $1
`

type GetOrderItemsRow struct {
        SkuID   int64
        OrderID int64
        Count   int64
}

func (q *Queries) GetOrderItems(ctx context.Context, orderID int64) ([]GetOrderItemsRow, error) <span class="cov8" title="9">{
        rows, err := q.db.Query(ctx, getOrderItems, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="9">defer rows.Close()
        var items []GetOrderItemsRow
        for rows.Next() </span><span class="cov10" title="15">{
                var i GetOrderItemsRow
                if err := rows.Scan(&amp;i.SkuID, &amp;i.OrderID, &amp;i.Count); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="15">items = append(items, i)</span>
        }
        <span class="cov8" title="9">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="9">return items, nil</span>
}

type InsertOrderItemsParams struct {
        SkuID     int64
        OrderID   int64
        Count     int64
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package pgorders

import (
        "context"
        "errors"
        "fmt"
        "time"

        "route256/loms/config"
        "route256/loms/internal/loms/adapters/pgorders/pgordersqry"
        "route256/loms/internal/loms/models"
        "route256/loms/pkg/pgcluster"
        "route256/loms/pkg/pgconnect"

        "github.com/jackc/pgx/v5"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

type OrdersRepo struct {
        Cluster *pgcluster.Cluster
}

func New(ctx context.Context, cfg config.OrdersRepoCfg, logger zerolog.Logger) (*OrdersRepo, error) <span class="cov1" title="1">{
        masterUrl := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=disable",
                cfg.User,
                cfg.Password,
                cfg.HostMaster,
                cfg.PortMaster,
                cfg.Name)

        slaveUrl := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=disable",
                cfg.User,
                cfg.Password,
                cfg.HostSlave,
                cfg.PortSlave,
                cfg.Name)

        masterPool, err := pgconnect.Connect(ctx, masterUrl, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">slavePool, err := pgconnect.Connect(ctx, slaveUrl, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">cluster := pgcluster.New().SetWriter(masterPool).AddReader(masterPool, slavePool)

        return &amp;OrdersRepo{
                Cluster: cluster,
        }, nil</span>
}

func (or *OrdersRepo) Create(ctx context.Context, order models.Order) (int64, error) <span class="cov6" title="4">{
        orderData := orderToDTO(order)
        pool, err := or.Cluster.GetWriter()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov6" title="4">tx, err := pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("connection acquire fail: %w", err)
        }</span>
        <span class="cov6" title="4">defer func() </span><span class="cov6" title="4">{
                if err = tx.Rollback(ctx); err != nil </span><span class="cov6" title="4">{
                        if !errors.Is(err, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                log.Error().Err(err).Caller().Send()
                        }</span>
                }
        }()

        // Каждый раз создается через New() что бы можно было подменять пулл из кластера
        <span class="cov6" title="4">qtx := pgordersqry.New(tx)

        orderID, err := qtx.CreateOrder(ctx, pgordersqry.CreateOrderParams{
                UserID:    orderData.UserID,
                Status:    orderData.Status,
                CreatedAt: orderData.CreatedAt,
                UpdatedAt: orderData.UpdatedAt,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("query fail: %w", err)
        }</span>

        <span class="cov6" title="4">itemsData := itemsToDTO(orderID, order.Items)

        _, err = qtx.InsertOrderItems(ctx, itemsData)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("query fail: %w", err)
        }</span>

        <span class="cov6" title="4">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("transaction commit fail: %w", err)
        }</span>

        <span class="cov6" title="4">return orderID, nil</span>
}

func (or *OrdersRepo) SetStatus(ctx context.Context, orderID int64, status models.OrderStatus) error <span class="cov8" title="7">{
        qry := `UPDATE orders.orders
                                SET status=$1, updated_at=$2
                                WHERE id=$3`
        pool, err := or.Cluster.GetWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // sqlc не умеет возвращать commandTag (нужен для обработки ошибки)
        <span class="cov8" title="7">tag, err := pool.Exec(ctx, qry, statusToDTO(status), time.Now(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="7">if tag.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return models.ErrOrderNotFound
        }</span>

        <span class="cov8" title="7">return nil</span>
}

func (or *OrdersRepo) GetByOrderID(ctx context.Context, orderID int64) (models.Order, error) <span class="cov10" title="12">{
        pool, err := or.Cluster.GetReader()
        if err != nil </span><span class="cov0" title="0">{
                return models.Order{}, err
        }</span>

        <span class="cov10" title="12">qPool := pgordersqry.New(pool)

        oderData, err := qPool.GetOrderById(ctx, orderID)
        if err != nil </span><span class="cov4" title="3">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov4" title="3">{
                        return models.Order{}, models.ErrOrderNotFound
                }</span>
                <span class="cov0" title="0">return models.Order{}, err</span>
        }

        <span class="cov8" title="9">itemsData, err := qPool.GetOrderItems(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return models.Order{}, err
        }</span>

        <span class="cov8" title="9">return orderToDomain(oderData, itemsData), nil</span>
}

func (or *OrdersRepo) Close() error <span class="cov1" title="1">{
        or.Cluster.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package pgstocksqry

import (
        "context"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
        Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
        Query(context.Context, string, ...interface{}) (pgx.Rows, error)
        QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries <span class="cov10" title="15">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0

package pgstocksqry

import (
        "database/sql/driver"
        "fmt"

        "github.com/jackc/pgx/v5/pgtype"
)

type OrdersOrderStatus string

const (
        OrdersOrderStatusUnknown         OrdersOrderStatus = "Unknown"
        OrdersOrderStatusNew             OrdersOrderStatus = "New"
        OrdersOrderStatusAwaitingPayment OrdersOrderStatus = "AwaitingPayment"
        OrdersOrderStatusPayed           OrdersOrderStatus = "Payed"
        OrdersOrderStatusCancelled       OrdersOrderStatus = "Cancelled"
        OrdersOrderStatusFailed          OrdersOrderStatus = "Failed"
)

func (e *OrdersOrderStatus) Scan(src interface{}) error <span class="cov0" title="0">{
        switch s := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                *e = OrdersOrderStatus(s)</span>
        case string:<span class="cov0" title="0">
                *e = OrdersOrderStatus(s)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported scan type for OrdersOrderStatus: %T", src)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type NullOrdersOrderStatus struct {
        OrdersOrderStatus OrdersOrderStatus
        Valid             bool // Valid is true if OrdersOrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrdersOrderStatus) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                ns.OrdersOrderStatus, ns.Valid = "", false
                return nil
        }</span>
        <span class="cov0" title="0">ns.Valid = true
        return ns.OrdersOrderStatus.Scan(value)</span>
}

// Value implements the driver Valuer interface.
func (ns NullOrdersOrderStatus) Value() (driver.Value, error) <span class="cov0" title="0">{
        if !ns.Valid </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return string(ns.OrdersOrderStatus), nil</span>
}

type OrdersOrder struct {
        ID        int64
        UserID    int64
        Status    OrdersOrderStatus
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}

type OrdersOrderItem struct {
        SkuID     int64
        OrderID   int64
        Count     int64
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}

type StocksStock struct {
        ID        int64
        Available int64
        Reserved  int64
        CreatedAt pgtype.Timestamp
        UpdatedAt pgtype.Timestamp
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package pgstocksqry

import (
        "context"
)

const cancelReservation = `-- name: CancelReservation :exec
UPDATE stocks.stocks
SET reserved = reserved - $1
WHERE id = $2
`

type CancelReservationParams struct {
        Reserved int64
        ID       int64
}

func (q *Queries) CancelReservation(ctx context.Context, arg CancelReservationParams) error <span class="cov6" title="4">{
        _, err := q.db.Exec(ctx, cancelReservation, arg.Reserved, arg.ID)
        return err
}</span>

const getStockBySKU = `-- name: GetStockBySKU :one
SELECT available, reserved
FROM stocks.stocks
WHERE id = $1
`

type GetStockBySKURow struct {
        Available int64
        Reserved  int64
}

func (q *Queries) GetStockBySKU(ctx context.Context, id int64) (GetStockBySKURow, error) <span class="cov9" title="8">{
        row := q.db.QueryRow(ctx, getStockBySKU, id)
        var i GetStockBySKURow
        err := row.Scan(&amp;i.Available, &amp;i.Reserved)
        return i, err
}</span>

const removePayedReservation = `-- name: RemovePayedReservation :exec
UPDATE stocks.stocks
SET available = available - $1,
    reserved = reserved - $1
WHERE id = $2
`

type RemovePayedReservationParams struct {
        Available int64
        ID        int64
}

func (q *Queries) RemovePayedReservation(ctx context.Context, arg RemovePayedReservationParams) error <span class="cov1" title="1">{
        _, err := q.db.Exec(ctx, removePayedReservation, arg.Available, arg.ID)
        return err
}</span>

const reserveStocks = `-- name: ReserveStocks :exec
UPDATE stocks.stocks
SET reserved = reserved + $1
WHERE id = $2
`

type ReserveStocksParams struct {
        Reserved int64
        ID       int64
}

func (q *Queries) ReserveStocks(ctx context.Context, arg ReserveStocksParams) error <span class="cov5" title="3">{
        _, err := q.db.Exec(ctx, reserveStocks, arg.Reserved, arg.ID)
        return err
}</span>

const retrieveStockForUpdate = `-- name: RetrieveStockForUpdate :one
SELECT available, reserved
FROM stocks.stocks
WHERE id = $1 FOR UPDATE
`

type RetrieveStockForUpdateRow struct {
        Available int64
        Reserved  int64
}

func (q *Queries) RetrieveStockForUpdate(ctx context.Context, id int64) (RetrieveStockForUpdateRow, error) <span class="cov10" title="10">{
        row := q.db.QueryRow(ctx, retrieveStockForUpdate, id)
        var i RetrieveStockForUpdateRow
        err := row.Scan(&amp;i.Available, &amp;i.Reserved)
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package pgstocks

import (
        "errors"
        "fmt"

        "route256/loms/config"
        "route256/loms/internal/loms/adapters/pgstocks/pgstocksqry"
        "route256/loms/internal/loms/models"
        "route256/loms/pkg/pgcluster"
        "route256/loms/pkg/pgconnect"

        "github.com/jackc/pgx/v5"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "golang.org/x/net/context"
)

type StocksRepo struct {
        Cluster *pgcluster.Cluster
}

func New(ctx context.Context, cfg config.StocksRepoCfg, logger zerolog.Logger) (*StocksRepo, error) <span class="cov1" title="1">{
        masterUrl := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=disable",
                cfg.User,
                cfg.Password,
                cfg.HostMaster,
                cfg.PortMaster,
                cfg.Name)

        slaveUrl := fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=disable",
                cfg.User,
                cfg.Password,
                cfg.HostSlave,
                cfg.PortSlave,
                cfg.Name)

        masterPool, err := pgconnect.Connect(ctx, masterUrl, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">slavePool, err := pgconnect.Connect(ctx, slaveUrl, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">cluster := pgcluster.New().SetWriter(masterPool).AddReader(masterPool, slavePool)

        return &amp;StocksRepo{
                Cluster: cluster,
        }, nil</span>
}

func (s *StocksRepo) Reserve(ctx context.Context, order models.Order) error <span class="cov7" title="4">{
        pool, err := s.Cluster.GetWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">tx, err := pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection acquire fail: %w", err)
        }</span>
        <span class="cov7" title="4">defer func() </span><span class="cov7" title="4">{
                if err = tx.Rollback(ctx); err != nil </span><span class="cov4" title="2">{
                        if !errors.Is(err, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                log.Error().Err(err).Caller().Send()
                        }</span>
                }
        }()

        // Каждый раз создается через New() что бы можно было подменять пулл из кластера
        <span class="cov7" title="4">qtx := pgstocksqry.New(tx)

        for _, item := range order.Items </span><span class="cov7" title="5">{
                var stocksData pgstocksqry.RetrieveStockForUpdateRow
                stocksData, err = qtx.RetrieveStockForUpdate(ctx, int64(item.SKUid))
                if err != nil </span><span class="cov1" title="1">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov1" title="1">{
                                return models.ErrItemNotFound
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov7" title="4">toReserve := int64(item.Count)
                if stocksData.Available &lt; stocksData.Reserved+toReserve </span><span class="cov1" title="1">{
                        err = models.ErrInsufficientStock
                        return err
                }</span>

                <span class="cov5" title="3">err = qtx.ReserveStocks(ctx, pgstocksqry.ReserveStocksParams{
                        Reserved: toReserve,
                        ID:       int64(item.SKUid),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction commit fail: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (s *StocksRepo) ReserveRemove(ctx context.Context, order models.Order) error <span class="cov1" title="1">{
        pool, err := s.Cluster.GetWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">tx, err := pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection acquire fail: %w", err)
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                if err = tx.Rollback(ctx); err != nil </span><span class="cov1" title="1">{
                        if !errors.Is(err, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                log.Error().Err(err).Caller().Send()
                        }</span>
                }
        }()

        <span class="cov1" title="1">qtx := pgstocksqry.New(tx)

        for _, item := range order.Items </span><span class="cov1" title="1">{
                var stocksData pgstocksqry.RetrieveStockForUpdateRow
                stocksData, err = qtx.RetrieveStockForUpdate(ctx, int64(item.SKUid))
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                                return models.ErrItemNotFound
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov1" title="1">toReserve := int64(item.Count)
                if stocksData.Reserved &lt; toReserve </span><span class="cov0" title="0">{
                        err = models.ErrReservationConflict
                        return err
                }</span>

                <span class="cov1" title="1">err = qtx.RemovePayedReservation(ctx, pgstocksqry.RemovePayedReservationParams{
                        Available: toReserve,
                        ID:        int64(item.SKUid),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction commit fail: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *StocksRepo) ReserveCancel(ctx context.Context, order models.Order) error <span class="cov4" title="2">{
        pool, err := s.Cluster.GetWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="2">tx, err := pool.Begin(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection acquire fail: %w", err)
        }</span>
        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                if err = tx.Rollback(ctx); err != nil </span><span class="cov4" title="2">{
                        if !errors.Is(err, pgx.ErrTxClosed) </span><span class="cov0" title="0">{
                                log.Error().Err(err).Caller().Send()
                        }</span>
                }
        }()

        <span class="cov4" title="2">qtx := pgstocksqry.New(tx)

        for _, item := range order.Items </span><span class="cov7" title="4">{
                var stocksData pgstocksqry.RetrieveStockForUpdateRow
                stocksData, err = qtx.RetrieveStockForUpdate(ctx, int64(item.SKUid))
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                                return models.ErrItemNotFound
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov7" title="4">toReserve := int64(item.Count)
                if stocksData.Reserved &lt; toReserve </span><span class="cov0" title="0">{
                        err = models.ErrReservationConflict
                        return err
                }</span>

                <span class="cov7" title="4">err = qtx.CancelReservation(ctx, pgstocksqry.CancelReservationParams{
                        Reserved: toReserve,
                        ID:       int64(item.SKUid),
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov4" title="2">if err = tx.Commit(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction commit fail: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (s *StocksRepo) GetBySKU(ctx context.Context, skuID uint32) (int64, error) <span class="cov10" title="8">{
        pool, err := s.Cluster.GetReader()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov10" title="8">stocksData, err := pgstocksqry.New(pool).GetStockBySKU(ctx, int64(skuID))
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov1" title="1">{
                        return 0, models.ErrItemNotFound
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov9" title="7">return stocksData.Available - stocksData.Reserved, nil</span>
}

func (s *StocksRepo) Close() error <span class="cov1" title="1">{
        s.Cluster.Close()
        return nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package stocksmem

import (
        "context"
        _ "embed"
        "encoding/json"
        "sync"

        "route256/loms/internal/loms/models"
)

//go:embed stock-data.json
var stockData []byte

type Stocks struct {
        mu       *sync.RWMutex
        stocks   map[uint32]int64 // Общее количество доступных для заказа товаров (skuID -&gt; amount). Количество уменьшается только после оплаты
        reserved map[uint32]int64 // Зарезервированные товары (не оплаченные) (skuID -&gt; amount)
}

func New() (*Stocks, error) <span class="cov0" title="0">{
        stocks := &amp;Stocks{
                mu:       &amp;sync.RWMutex{},
                stocks:   make(map[uint32]int64),
                reserved: make(map[uint32]int64),
        }

        if err := stocks.uploadStockData(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return stocks, nil</span>
}

func (s *Stocks) Reserve(_ context.Context, order models.Order) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var err error
        changesSnapshot := make(map[uint32]int64)

        // для восстановления данных в исходное состояние в случае возникновения ошибки
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        for sku, amount := range changesSnapshot </span><span class="cov0" title="0">{
                                s.reserved[sku] -= amount
                        }</span>
                }
        }()

        <span class="cov0" title="0">for _, item := range order.Items </span><span class="cov0" title="0">{
                available, ok := s.stocks[item.SKUid]
                if !ok </span><span class="cov0" title="0">{
                        err = models.ErrItemNotFound
                        return err
                }</span>

                <span class="cov0" title="0">toReserve := int64(item.Count)
                if available &lt; s.reserved[item.SKUid]+toReserve </span><span class="cov0" title="0">{
                        err = models.ErrInsufficientStock
                        return err
                }</span>

                <span class="cov0" title="0">changesSnapshot[item.SKUid] += toReserve
                s.reserved[item.SKUid] += toReserve</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Stocks) ReserveRemove(_ context.Context, order models.Order) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var err error
        changesSnapshot := make(map[uint32]int64)

        // для восстановления данных в исходное состояние в случае возникновения ошибки
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        for sku, amount := range changesSnapshot </span><span class="cov0" title="0">{
                                s.reserved[sku] += amount
                                s.stocks[sku] += amount
                        }</span>
                }
        }()

        <span class="cov0" title="0">for _, item := range order.Items </span><span class="cov0" title="0">{
                // не проверяем s.stocks так как согласованность s.reserved c s.stocks проверяется в Reserve()
                reserved, ok := s.reserved[item.SKUid]
                if !ok </span><span class="cov0" title="0">{
                        err = models.ErrItemNotFound
                        return err
                }</span>

                <span class="cov0" title="0">toRemove := int64(item.Count)
                if reserved &lt; toRemove </span><span class="cov0" title="0">{
                        err = models.ErrReservationConflict
                        return err
                }</span>

                <span class="cov0" title="0">changesSnapshot[item.SKUid] += toRemove
                s.reserved[item.SKUid] -= toRemove
                s.stocks[item.SKUid] -= toRemove</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Stocks) ReserveCancel(_ context.Context, order models.Order) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var err error
        changesSnapshot := make(map[uint32]int64)

        // для восстановления данных в исходное состояние в случае возникновения ошибки
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        for sku, amount := range changesSnapshot </span><span class="cov0" title="0">{
                                s.reserved[sku] += amount
                        }</span>
                }
        }()

        <span class="cov0" title="0">for _, item := range order.Items </span><span class="cov0" title="0">{
                reserved, ok := s.reserved[item.SKUid]
                if !ok </span><span class="cov0" title="0">{
                        err = models.ErrItemNotFound
                        return err
                }</span>

                <span class="cov0" title="0">toRemove := int64(item.Count)
                if reserved &lt; toRemove </span><span class="cov0" title="0">{
                        err = models.ErrReservationConflict
                        return err
                }</span>

                <span class="cov0" title="0">changesSnapshot[item.SKUid] += toRemove
                s.reserved[item.SKUid] -= toRemove</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Stocks) GetBySKU(_ context.Context, skuID uint32) (int64, error) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if _, ok := s.stocks[skuID]; !ok </span><span class="cov0" title="0">{
                return 0, models.ErrItemNotFound
        }</span>
        // нет проверки на наличие в s.reserved так как нерелевантна (в любом случае получим zero value)
        <span class="cov0" title="0">total := s.stocks[skuID] - s.reserved[skuID]

        return total, nil</span>
}

// UploadStockData - добавляет данные из stock-data.json. Перезаписывает данные в случае их наличия
func (s *Stocks) uploadStockData() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        type stockItem struct {
                SKU        uint32 `json:"sku"`
                TotalCount uint32 `json:"total_count"`
                Reserved   uint32 `json:"reserved"`
        }

        var stockItems []stockItem

        if err := json.Unmarshal(stockData, &amp;stockItems); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, stock := range stockItems </span><span class="cov0" title="0">{
                s.stocks[stock.SKU] += int64(stock.TotalCount)
                s.reserved[stock.SKU] = int64(stock.Reserved)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package impl

import (
        "route256/loms/internal/loms/models"
        lomsservicev1 "route256/loms/pkg/api/loms/v1"
)

func ItemToDomain(item *lomsservicev1.Item) models.Item <span class="cov10" title="13">{
        return models.Item{
                SKUid: item.Sku,
                Count: item.Count,
        }
}</span>

func ItemToProto(item models.Item) *lomsservicev1.Item <span class="cov8" title="9">{
        return &amp;lomsservicev1.Item{
                Sku:   item.SKUid,
                Count: item.Count,
        }
}</span>

func OrderToDomain(req *lomsservicev1.OrderCreateRequest) models.Order <span class="cov8" title="8">{
        items := make([]models.Item, len(req.Items))
        for i, item := range req.Items </span><span class="cov10" title="13">{
                items[i] = ItemToDomain(item)
        }</span>
        <span class="cov8" title="8">return models.Order{
                UserID: req.User,
                Items:  items,
                Status: models.UnknownStatus,
        }</span>
}

func OrderToProto(order models.Order) *lomsservicev1.OrderInfoResponse <span class="cov6" title="5">{
        items := make([]*lomsservicev1.Item, len(order.Items))
        for i, item := range order.Items </span><span class="cov8" title="9">{
                items[i] = ItemToProto(item)
        }</span>
        <span class="cov6" title="5">return &amp;lomsservicev1.OrderInfoResponse{
                User:   order.UserID,
                Items:  items,
                Status: StatusToProto(order.Status),
        }</span>
}

func StatusToProto(status models.OrderStatus) lomsservicev1.Status <span class="cov6" title="5">{
        switch status </span>{
        case models.NewStatus:<span class="cov0" title="0">
                return lomsservicev1.Status_STATUS_NEW</span>
        case models.AwaitingPaymentStatus:<span class="cov3" title="2">
                return lomsservicev1.Status_STATUS_AWAITING_PAYMENT</span>
        case models.PayedStatus:<span class="cov3" title="2">
                return lomsservicev1.Status_STATUS_PAYED</span>
        case models.CancelledStatus:<span class="cov1" title="1">
                return lomsservicev1.Status_STATUS_CANCELLED</span>
        case models.FailedStatus:<span class="cov0" title="0">
                return lomsservicev1.Status_STATUS_FAILED</span>
        default:<span class="cov0" title="0">
                return lomsservicev1.Status_STATUS_UNKNOWN</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package impl

import (
        "errors"

        "route256/loms/internal/loms/models"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func mapError(err error) error <span class="cov10" title="21">{
        switch </span>{
        case errors.Is(err, models.ErrOrderNotFound):<span class="cov5" title="5">
                return status.Error(codes.NotFound, err.Error())</span>
        case errors.Is(err, models.ErrItemNotFound):<span class="cov5" title="4">
                return status.Error(codes.NotFound, err.Error())</span>
        case errors.Is(err, models.ErrInsufficientStock):<span class="cov3" title="2">
                return status.Error(codes.FailedPrecondition, err.Error())</span>
        case errors.Is(err, models.ErrReservationConflict):<span class="cov3" title="2">
                return status.Error(codes.FailedPrecondition, err.Error())</span>
        case errors.Is(err, models.ErrOrderStatusConflict):<span class="cov4" title="3">
                return status.Error(codes.FailedPrecondition, err.Error())</span>
        default:<span class="cov5" title="5">
                return status.Error(codes.Internal, "internal server error")</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package impl

import (
        "context"

        "route256/loms/internal/loms/models"
        lomsservicev1 "route256/loms/pkg/api/loms/v1"

        "github.com/rs/zerolog"
        "google.golang.org/protobuf/types/known/emptypb"
)

//go:generate minimock -i lomsServer -p impl_test
type lomsServer interface {
        OrderCreate(ctx context.Context, order models.Order) (int64, error)
        OrderInfo(ctx context.Context, orderID int64) (models.Order, error)
        OrderPay(ctx context.Context, orderID int64) error
        OrderCancel(ctx context.Context, orderID int64) error
        StocksInfo(ctx context.Context, skuID uint32) (int64, error)
}

var _ lomsservicev1.LOMSServer = (*Impl)(nil)

type Impl struct {
        log    zerolog.Logger
        server lomsServer
        lomsservicev1.UnimplementedLOMSServer
}

func New(
        log zerolog.Logger,
        server lomsServer,
) *Impl <span class="cov10" title="19">{
        return &amp;Impl{
                log:    log,
                server: server,
        }
}</span>

func (i *Impl) OrderCreate(ctx context.Context, req *lomsservicev1.OrderCreateRequest) (*lomsservicev1.OrderCreateResponse, error) <span class="cov7" title="8">{
        orderID, err := i.server.OrderCreate(ctx, OrderToDomain(req))
        if err != nil </span><span class="cov5" title="5">{
                i.log.Error().Err(err).Send()
                return nil, mapError(err)
        }</span>

        <span class="cov4" title="3">return &amp;lomsservicev1.OrderCreateResponse{OrderID: orderID}, nil</span>
}

func (i *Impl) OrderInfo(ctx context.Context, req *lomsservicev1.OrderInfoRequest) (*lomsservicev1.OrderInfoResponse, error) <span class="cov7" title="8">{
        order, err := i.server.OrderInfo(ctx, req.OrderID)
        if err != nil </span><span class="cov4" title="3">{
                i.log.Error().Err(err).Send()
                return nil, mapError(err)
        }</span>

        <span class="cov5" title="5">return OrderToProto(order), nil</span>
}

func (i *Impl) OrderPay(ctx context.Context, req *lomsservicev1.OrderPayRequest) (*emptypb.Empty, error) <span class="cov7" title="8">{
        err := i.server.OrderPay(ctx, req.OrderID)
        if err != nil </span><span class="cov6" title="6">{
                i.log.Error().Err(err).Send()
                return nil, mapError(err)
        }</span>

        <span class="cov3" title="2">return &amp;emptypb.Empty{}, nil</span>
}
func (i *Impl) OrderCancel(ctx context.Context, req *lomsservicev1.OrderCancelRequest) (*emptypb.Empty, error) <span class="cov6" title="7">{
        err := i.server.OrderCancel(ctx, req.OrderID)
        if err != nil </span><span class="cov5" title="4">{
                i.log.Error().Err(err).Send()
                return nil, mapError(err)
        }</span>

        <span class="cov4" title="3">return &amp;emptypb.Empty{}, nil</span>
}
func (i *Impl) StocksInfo(ctx context.Context, req *lomsservicev1.StocksInfoRequest) (*lomsservicev1.StocksInfoResponse, error) <span class="cov8" title="11">{
        count, err := i.server.StocksInfo(ctx, req.Sku)
        if err != nil </span><span class="cov4" title="3">{
                i.log.Error().Err(err).Send()
                return nil, mapError(err)
        }</span>

        <span class="cov7" title="8">return &amp;lomsservicev1.StocksInfoResponse{Count: uint64(count)}, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package interceptors

import (
        "context"
        "time"

        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

func LoggingInterceptor(logger zerolog.Logger) grpc.UnaryServerInterceptor <span class="cov1" title="1">{
        return func(
                ctx context.Context,
                req any,
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (resp any, err error) </span><span class="cov10" title="25">{
                logRequest(logger, req, info)

                defer func(start time.Time) </span><span class="cov10" title="25">{
                        if err != nil </span><span class="cov6" title="8">{
                                logEvent := logger.With().
                                        Str("method", info.FullMethod).
                                        Dur("duration", time.Since(start)).Logger()

                                st, _ := status.FromError(err)

                                switch st.Code() </span>{
                                case codes.NotFound, codes.InvalidArgument, codes.FailedPrecondition:<span class="cov6" title="8">
                                        logEvent.Warn().Err(err).Send()</span>
                                case codes.Internal:<span class="cov0" title="0">
                                        logEvent.Error().Err(err).Send()</span>
                                default:<span class="cov0" title="0">
                                        logEvent.Error().Err(err).Send()</span>
                                }

                                <span class="cov6" title="8">return</span>
                        }

                        <span class="cov8" title="17">logResponse(logger, time.Since(start), resp, info)</span>
                }(time.Now())

                <span class="cov10" title="25">return handler(logger.WithContext(ctx), req)</span>
        }
}

func logRequest(logger zerolog.Logger, req any, info *grpc.UnaryServerInfo) <span class="cov10" title="25">{
        reqProto, ok := req.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                logger.Warn().Msg("failed to cast request to proto.Message")
        }</span>

        <span class="cov10" title="25">reqBytes, err := protojson.Marshal(reqProto)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to marshal request")
        }</span>

        <span class="cov10" title="25">logger.Debug().
                Str("method", info.FullMethod).
                Bytes("request body", reqBytes).
                Send()</span>
}

func logResponse(logger zerolog.Logger, timeTaken time.Duration, resp any, info *grpc.UnaryServerInfo) <span class="cov8" title="17">{
        respProto, ok := resp.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                logger.Warn().Msg("failed to cast response to proto.Message")
        }</span>

        <span class="cov8" title="17">respBytes, err := protojson.Marshal(respProto)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn().Err(err).Msg("failed to marshal response")
        }</span>

        <span class="cov8" title="17">logger.Debug().
                Str("method", info.FullMethod).
                Dur("duration", timeTaken).
                Bytes("response", respBytes).
                Msg("received unary request")</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package interceptors

import (
        "context"
        "runtime/debug"

        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func RecoverPanic(ctx context.Context, req any, _ *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp any, err error) <span class="cov10" title="25">{
        logger := *zerolog.Ctx(ctx)

        defer func() </span><span class="cov10" title="25">{
                if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                        logger.Error().Any("panic", rec).Bytes("stack", debug.Stack()).Send()
                        err = status.Errorf(codes.Internal, "panic: %v", rec)
                }</span>
        }()

        <span class="cov10" title="25">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package interceptors

import (
        "context"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type validator interface {
        Validate() error
}

func Validate(ctx context.Context, req any, _ *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) <span class="cov10" title="25">{
        if v, ok := req.(validator); ok </span><span class="cov9" title="24">{
                if err := v.Validate(); err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>
        }
        <span class="cov10" title="25">return handler(ctx, req)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package ggrpc

import (
        "route256/loms/config"
        "route256/loms/internal/loms/ports/ggrpc/impl"
        "route256/loms/internal/loms/ports/ggrpc/interceptors"
        "route256/loms/internal/loms/resources"
        lomsservicev1 "route256/loms/pkg/api/loms/v1"

        "github.com/rs/zerolog"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"
)

func NewServer(_ config.Config, res resources.Resources) *grpc.Server <span class="cov8" title="1">{
        options := buildOptions(res.Log)

        server := grpc.NewServer(options...)
        reflection.Register(server)

        serverAdapter := impl.New(res.Log, res.UseCase)

        lomsservicev1.RegisterLOMSServer(server, serverAdapter)
        grpc_health_v1.RegisterHealthServer(server, health.NewServer())

        return server
}</span>

func buildOptions(log zerolog.Logger) []grpc.ServerOption <span class="cov8" title="1">{
        return []grpc.ServerOption{
                grpc.ChainUnaryInterceptor(
                        interceptors.LoggingInterceptor(log),
                        interceptors.RecoverPanic,
                        interceptors.Validate,
                ),
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package httpgate

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/rs/zerolog/log"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type errResp struct {
        Error string `json:"error"`
}

func errHandler(ctx context.Context, mux *runtime.ServeMux, marshaler runtime.Marshaler, w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        s, ok := status.FromError(err)
        if !ok </span><span class="cov0" title="0">{
                runtime.DefaultHTTPErrorHandler(ctx, mux, marshaler, w, r, err)
                return
        }</span>

        <span class="cov0" title="0">switch s.Code() </span>{
        case codes.InvalidArgument:<span class="cov0" title="0">
                customErr(w, http.StatusBadRequest, s.Message())</span>
        case codes.NotFound:<span class="cov0" title="0">
                customErr(w, http.StatusNotFound, s.Message())</span>
        case codes.FailedPrecondition:<span class="cov0" title="0">
                customErr(w, http.StatusPreconditionFailed, s.Message())</span>
        case codes.Internal:<span class="cov0" title="0">
                customErr(w, http.StatusInternalServerError, s.Message())</span>
        default:<span class="cov0" title="0">
                runtime.DefaultHTTPErrorHandler(ctx, mux, marshaler, w, r, err)</span>
        }

}

func customErr(w http.ResponseWriter, code int, msg string) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)

        errMsg := errResp{
                Error: msg,
        }
        if err := json.NewEncoder(w).Encode(errMsg); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Send()
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package httpgate

import (
        "context"
        "net/http"

        "route256/loms/config"
        lomsservicev1 "route256/loms/pkg/api/loms/v1"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

func New(ctx context.Context, cfg config.HTTPGateCfg) (*http.Server, error) <span class="cov8" title="1">{
        rmux := runtime.NewServeMux(runtime.WithErrorHandler(errHandler))

        conn, err := grpc.NewClient(cfg.LOMSAddress,
                grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">client := lomsservicev1.NewLOMSClient(conn)

        if err = lomsservicev1.RegisterLOMSHandlerClient(ctx, rmux, client); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mux := http.NewServeMux()
        mux.Handle("/", rmux)

        mux.HandleFunc("/swagger-ui/swagger.json", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.ServeFile(w, r, cfg.SwaggerFilePath)
        }</span>)

        // mount the Swagger UI that uses the OpenAPI specification path above
        <span class="cov8" title="1">mux.Handle("/swagger-ui/", http.StripPrefix("/swagger-ui/", http.FileServer(http.Dir(cfg.SwaggerDirPath))))

        return &amp;http.Server{
                Addr:    cfg.Address,
                Handler: mux,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package resources

import (
        "context"

        "route256/loms/config"
        "route256/loms/internal/loms/adapters/pgorders"
        "route256/loms/internal/loms/adapters/pgstocks"
        "route256/loms/internal/loms/usecase"

        "route256/loms/pkg/logger"

        "github.com/rs/zerolog"
)

type Resources struct {
        Log           zerolog.Logger
        UseCase       *usecase.UseCase
        stopResources []func() error
}

func New(ctx context.Context, cfg config.Config) (Resources, error) <span class="cov1" title="1">{
        log, err := logger.New(cfg.LoggerLVL)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">stockStorage, err := pgstocks.New(ctx, cfg.StocksRepo, log)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">orderStorage, err := pgorders.New(ctx, cfg.OrdersRepo, log)
        if err != nil </span><span class="cov0" title="0">{
                return Resources{}, err
        }</span>

        <span class="cov1" title="1">return Resources{
                Log: log,
                UseCase: usecase.New(
                        log,
                        orderStorage,
                        stockStorage,
                ),
                stopResources: []func() error{
                        orderStorage.Close,
                        stockStorage.Close,
                },
        }, nil</span>
}

func (r Resources) Stop() <span class="cov1" title="1">{
        for _, stop := range r.stopResources </span><span class="cov10" title="2">{
                if err := stop(); err != nil </span><span class="cov0" title="0">{
                        r.Log.Error().Err(err).Send()
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package loms

import (
        "context"
        "errors"
        "fmt"
        "net"
        "net/http"
        "os/signal"
        "syscall"
        "time"

        "route256/loms/config"
        "route256/loms/internal/loms/ports/ggrpc"
        "route256/loms/internal/loms/ports/httpgate"
        "route256/loms/internal/loms/resources"

        "github.com/rs/zerolog/log"
        "golang.org/x/sync/errgroup"
)

const gracefulTimeout = 10 * time.Second

func Run(ctx context.Context, cfg config.Config) error <span class="cov8" title="1">{
        ctx, cancel := signal.NotifyContext(ctx, syscall.SIGINT, syscall.SIGTERM)
        defer cancel()

        grpcListener, err := net.Listen("tcp", fmt.Sprintf(":%s", cfg.Port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">res, err := resources.New(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer res.Stop()

        g, gCtx := errgroup.WithContext(ctx)

        grpcServer := ggrpc.NewServer(cfg, res)
        gatewayServer, err := httpgate.New(gCtx, cfg.Gateway)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                log.Info().Msg(fmt.Sprintf("starting server: %s", cfg.Port))
                return grpcServer.Serve(grpcListener)
        }</span>)
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                log.Info().Msg(fmt.Sprintf("starting gateway: %s", cfg.Gateway.Address))
                if err = gatewayServer.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                &lt;-gCtx.Done()
                log.Info().Msg("Got interruption signal")
                shutDownCtx, cancel := context.WithTimeout(context.Background(), gracefulTimeout)
                defer cancel()
                grpcServer.GracefulStop()
                return gatewayServer.Shutdown(shutDownCtx)
        }</span>)

        <span class="cov8" title="1">if err = g.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Send()
                return err
        }</span>

        <span class="cov8" title="1">log.Info().Msg("server was gracefully shut down")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package usecase

import (
        "context"

        "route256/loms/internal/loms/models"

        "github.com/rs/zerolog"
)

//go:generate minimock -i stockProvider -p usecase_test
type stockProvider interface {
        Reserve(ctx context.Context, order models.Order) error
        ReserveRemove(ctx context.Context, order models.Order) error
        ReserveCancel(ctx context.Context, order models.Order) error
        GetBySKU(ctx context.Context, skuID uint32) (int64, error)
}

//go:generate minimock -i orderManager -p usecase_test
type orderManager interface {
        Create(ctx context.Context, order models.Order) (int64, error)
        SetStatus(ctx context.Context, orderID int64, status models.OrderStatus) error
        GetByOrderID(ctx context.Context, orderID int64) (models.Order, error)
}

type UseCase struct {
        log    zerolog.Logger
        stocks stockProvider
        orders orderManager
}

func New(
        log zerolog.Logger,
        orders orderManager,
        stocks stockProvider,
) *UseCase <span class="cov10" title="20">{
        return &amp;UseCase{
                log:    log,
                orders: orders,
                stocks: stocks,
        }
}</span>

func (uc *UseCase) OrderCreate(ctx context.Context, order models.Order) (int64, error) <span class="cov7" title="9">{
        var err error
        order.Status = models.NewStatus

        orderID, err := uc.orders.Create(ctx, order)
        if err != nil </span><span class="cov3" title="2">{
                return 0, err
        }</span>

        <span class="cov6" title="7">defer func() </span><span class="cov6" title="7">{
                if err != nil </span><span class="cov4" title="3">{
                        uc.log.Error().Err(err).Str("status", "fail").Int64("orderID", orderID).Msg("reservation failed")
                        err = uc.orders.SetStatus(ctx, orderID, models.FailedStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "FAILED").Int64("orderID", orderID).Send()
                        }</span>
                } else<span class="cov5" title="4"> {
                        uc.log.Debug().Str("status", "success").Int64("orderID", orderID).Msg("reservation success")
                        err = uc.orders.SetStatus(ctx, orderID, models.AwaitingPaymentStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "AWAITING_PAYMENT").Int64("orderID", orderID).Send()
                        }</span>
                }
        }()

        <span class="cov6" title="7">if err = uc.stocks.Reserve(ctx, order); err != nil </span><span class="cov4" title="3">{
                return 0, err
        }</span>

        <span class="cov5" title="4">return orderID, nil</span>
}
func (uc *UseCase) OrderInfo(ctx context.Context, orderID int64) (models.Order, error) <span class="cov6" title="7">{
        order, err := uc.orders.GetByOrderID(ctx, orderID)
        if err != nil </span><span class="cov3" title="2">{
                return models.Order{}, err
        }</span>

        <span class="cov5" title="5">return order, nil</span>
}
func (uc *UseCase) OrderPay(ctx context.Context, orderID int64) error <span class="cov7" title="8">{
        order, err := uc.orders.GetByOrderID(ctx, orderID)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        <span class="cov6" title="6">if order.Status != models.AwaitingPaymentStatus </span><span class="cov3" title="2">{
                return models.ErrOrderStatusConflict
        }</span>

        <span class="cov5" title="4">defer func() </span><span class="cov5" title="4">{
                if err != nil </span><span class="cov1" title="1">{
                        uc.log.Error().Err(err).Str("status", "fail").Int64("orderID", orderID).Msg("reservation removal failed")
                        err = uc.orders.SetStatus(ctx, orderID, models.FailedStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "FAILED").Int64("orderID", orderID).Send()
                        }</span>
                } else<span class="cov4" title="3"> {
                        uc.log.Debug().Str("status", "success").Int64("orderID", orderID).Msg("reservation removal success")
                        err = uc.orders.SetStatus(ctx, orderID, models.PayedStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "PAYED").Int64("orderID", orderID).Send()
                        }</span>
                }
        }()

        // Нужно записать результата в err что бы его можно было обработать в defer
        <span class="cov5" title="4">err = uc.stocks.ReserveRemove(ctx, order)
        return err</span>
}
func (uc *UseCase) OrderCancel(ctx context.Context, orderID int64) error <span class="cov7" title="9">{
        order, err := uc.orders.GetByOrderID(ctx, orderID)
        if err != nil </span><span class="cov3" title="2">{
                return err
        }</span>

        // Оставим возможность отмены заказа только со статусом new и awaiting_payment
        <span class="cov6" title="7">if order.Status != models.AwaitingPaymentStatus &amp;&amp; order.Status != models.NewStatus </span><span class="cov3" title="2">{
                return models.ErrOrderStatusConflict
        }</span>

        <span class="cov5" title="5">defer func() </span><span class="cov5" title="5">{
                if err != nil </span><span class="cov1" title="1">{
                        uc.log.Error().Err(err).Str("status", "fail").Int64("orderID", orderID).Msg("reservation cancellation failed")
                        err = uc.orders.SetStatus(ctx, orderID, models.FailedStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "FAILED").Int64("orderID", orderID).Send()
                        }</span>
                } else<span class="cov5" title="4"> {
                        uc.log.Debug().Str("status", "success").Int64("orderID", orderID).Msg("reservation cancellation success")
                        err = uc.orders.SetStatus(ctx, orderID, models.CancelledStatus)
                        if err != nil </span><span class="cov1" title="1">{
                                uc.log.Error().Err(err).Str("set fail", "CANCELLED").Int64("orderID", orderID).Send()
                        }</span>
                }
        }()

        // Нужно записать результата в err что бы его можно было обработать в defer
        <span class="cov5" title="5">err = uc.stocks.ReserveCancel(ctx, order)
        return err</span>
}
func (uc *UseCase) StocksInfo(ctx context.Context, skuID uint32) (int64, error) <span class="cov7" title="10">{
        amount, err := uc.stocks.GetBySKU(ctx, skuID)
        if err != nil </span><span class="cov3" title="2">{
                return 0, err
        }</span>

        <span class="cov7" title="8">return amount, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
